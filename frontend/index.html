<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="refresh" content="0; url=chat.html">
    <title>GIDEON 3.0 - Redirecting...</title>
    <script>window.location.href = 'chat.html';</script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00ff;
            --neon-blue: #0080ff;
            --neon-purple: #8000ff;
            --dark-bg: #0a0a0f;
            --dark-card: rgba(15, 15, 25, 0.8);
            --glass-border: rgba(0, 245, 255, 0.2);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--dark-bg);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
            overflow-x: hidden;
        }
        
        /* Animated background grid */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(90deg, rgba(0,245,255,0.03) 1px, transparent 1px),
                linear-gradient(rgba(0,245,255,0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes gridMove {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(50px); }
        }
        
        /* Glowing orbs background */
        body::after {
            content: '';
            position: fixed;
            top: 20%;
            left: 10%;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0,245,255,0.15) 0%, transparent 70%);
            border-radius: 50%;
            filter: blur(60px);
            animation: floatOrb 8s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes floatOrb {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(100px, 50px) scale(1.2); }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }
        
        h1 {
            font-family: 'Orbitron', monospace;
            font-size: 3.5em;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(0,245,255,0.5);
            letter-spacing: 8px;
            animation: glowPulse 2s ease-in-out infinite;
        }
        
        @keyframes glowPulse {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0,245,255,0.5)); }
            50% { filter: drop-shadow(0 0 40px rgba(0,245,255,0.8)); }
        }
        
        .subtitle {
            font-family: 'Orbitron', monospace;
            font-size: 0.9em;
            color: var(--neon-cyan);
            letter-spacing: 4px;
            margin-top: 10px;
            opacity: 0.8;
        }
        
        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 20px;
            background: var(--dark-card);
            border: 1px solid var(--glass-border);
            border-radius: 30px;
            margin-top: 15px;
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            letter-spacing: 2px;
        }
        
        .status::before {
            content: '';
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
            animation: statusPulse 1.5s infinite;
        }
        
        .status.online::before { background: var(--neon-cyan); box-shadow: 0 0 15px var(--neon-cyan); }
        .status.offline::before { background: #ff3366; box-shadow: 0 0 15px #ff3366; }
        
        @keyframes statusPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }
        
        /* ========== SECURITY BADGE ========== */
        .security-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 200, 100, 0.05));
            border: 1px solid rgba(0, 255, 136, 0.4);
            border-radius: 20px;
            margin-top: 15px;
            margin-left: 10px;
            font-family: 'Orbitron', monospace;
            font-size: 0.7em;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .security-badge:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        .security-badge .security-icon {
            font-size: 1em;
        }
        
        .security-badge .security-text {
            color: #00ff88;
            font-weight: 600;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
        }
        
        .security-badge.secure {
            border-color: rgba(0, 255, 136, 0.4);
        }
        
        .security-badge.secure .security-text {
            color: #00ff88;
        }
        
        .security-badge.warning {
            border-color: rgba(255, 200, 0, 0.5);
            background: linear-gradient(135deg, rgba(255, 200, 0, 0.1), rgba(200, 150, 0, 0.05));
        }
        
        .security-badge.warning .security-icon::before {
            content: '‚ö†Ô∏è';
        }
        
        .security-badge.warning .security-text {
            color: #ffc800;
            text-shadow: 0 0 8px rgba(255, 200, 0, 0.5);
        }
        
        /* Security Details Popup */
        .security-popup {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 10px;
            width: 280px;
            background: linear-gradient(135deg, rgba(10, 15, 30, 0.98), rgba(5, 10, 25, 0.98));
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 16px;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .security-popup.visible {
            display: block;
            animation: fadeInDown 0.2s ease-out;
        }
        
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .security-popup-header {
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            color: #00ff88;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            letter-spacing: 1px;
        }
        
        .security-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .security-item-label {
            font-family: 'Rajdhani', sans-serif;
        }
        
        .security-item-value {
            font-family: 'JetBrains Mono', monospace;
            color: #00ff88;
        }
        
        .security-item-value.ok { color: #00ff88; }
        .security-item-value.warning { color: #ffc800; }
        .security-item-value.error { color: #ff4444; }
        
        /* Level indicator */
        .level-indicator {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 25px;
            background: var(--dark-card);
            border: 2px solid var(--glass-border);
            border-radius: 30px;
            margin-top: 15px;
            margin-left: 15px;
            font-family: 'Orbitron', monospace;
            font-size: 0.85em;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }
        
        .level-indicator:hover {
            transform: scale(1.02);
        }
        
        .level-indicator .level-icon {
            font-size: 1.2em;
        }
        
        .level-indicator .level-text {
            text-transform: uppercase;
            font-weight: 700;
        }
        
        /* NORMAL LEVEL - Blue/Cyan - Friendly Assistant */
        .level-indicator.normal {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }
        .level-indicator.normal .level-text { color: var(--neon-cyan); }
        .level-indicator.normal .level-desc { color: rgba(0, 245, 255, 0.7); }
        
        /* ADVANCED LEVEL - Purple - Deep Analysis */
        .level-indicator.advanced {
            border-color: var(--neon-purple);
            box-shadow: 0 0 20px rgba(128, 0, 255, 0.4);
            background: linear-gradient(135deg, rgba(128, 0, 255, 0.1), rgba(15, 15, 25, 0.8));
        }
        .level-indicator.advanced .level-text { color: var(--neon-purple); }
        .level-indicator.advanced .level-desc { color: rgba(128, 0, 255, 0.7); }
        
        /* PILOT LEVEL - Green - Full Autonomy (Gideon Mode) */
        .level-indicator.pilot {
            border-color: #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.15), rgba(15, 15, 25, 0.8));
            animation: pilotGlow 2s ease-in-out infinite;
        }
        .level-indicator.pilot .level-text { color: #00ff88; }
        .level-indicator.pilot .level-desc { color: rgba(0, 255, 136, 0.7); }
        
        /* Level description */
        .level-desc {
            font-size: 0.6em;
            font-weight: 400;
            letter-spacing: 1px;
            opacity: 0.8;
        }
        
        /* Level Selector Panel */
        .level-selector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid var(--neon-cyan);
            border-radius: 20px;
            padding: 30px;
            z-index: 10001;
            display: none;
            min-width: 400px;
            box-shadow: 0 0 60px rgba(0, 245, 255, 0.3);
            backdrop-filter: blur(20px);
        }
        
        .level-selector.show {
            display: block;
            animation: levelSelectorOpen 0.3s ease-out forwards;
        }
        
        @keyframes levelSelectorOpen {
            from { transform: translate(-50%, -50%) scale(0.9); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .level-selector-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2em;
            color: var(--neon-cyan);
            text-align: center;
            margin-bottom: 25px;
            letter-spacing: 3px;
        }
        
        .level-option {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            margin: 10px 0;
            background: var(--dark-card);
            border: 2px solid transparent;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .level-option:hover {
            transform: translateX(5px);
        }
        
        .level-option.normal-opt:hover,
        .level-option.normal-opt.selected {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }
        
        .level-option.advanced-opt:hover,
        .level-option.advanced-opt.selected {
            border-color: var(--neon-purple);
            box-shadow: 0 0 20px rgba(128, 0, 255, 0.3);
        }
        
        .level-option.pilot-opt:hover,
        .level-option.pilot-opt.selected {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        .level-option-icon {
            font-size: 2em;
            width: 50px;
            text-align: center;
        }
        
        .level-option-content {
            flex: 1;
        }
        
        .level-option-name {
            font-family: 'Orbitron', monospace;
            font-size: 1.1em;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .normal-opt .level-option-name { color: var(--neon-cyan); }
        .advanced-opt .level-option-name { color: var(--neon-purple); }
        .pilot-opt .level-option-name { color: #00ff88; }
        
        .level-option-desc {
            font-size: 0.85em;
            color: #888;
        }
        
        .level-option-features {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 8px;
        }
        
        .level-feature {
            font-size: 0.7em;
            padding: 2px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            color: #666;
        }
        
        .level-selector-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
        }
        
        .level-selector-overlay.show {
            display: block;
        }
        
        /* Personality trait badge */
        .personality-trait {
            font-size: 0.65rem;
            padding: 2px 8px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-left: 8px;
            font-style: italic;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }
        .level-indicator.advanced .personality-trait {
            background: rgba(176, 0, 255, 0.1);
            border-color: rgba(176, 0, 255, 0.2);
        }
        .level-indicator.pilot .personality-trait {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.2);
        }
        
        @keyframes pilotGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.8); }
        }
        
        /* Pilot Mode Active - Full screen effect */
        body.pilot-mode-active {
            --neon-cyan: #00ff88;
        }
        
        body.pilot-mode-active::before {
            background: 
                linear-gradient(90deg, rgba(0,255,136,0.05) 1px, transparent 1px),
                linear-gradient(rgba(0,255,136,0.05) 1px, transparent 1px);
        }
        
        body.pilot-mode-active::after {
            background: radial-gradient(circle, rgba(0,255,136,0.2) 0%, transparent 70%);
        }
        
        body.pilot-mode-active .card {
            border-color: rgba(0, 255, 136, 0.3);
        }
        
        body.pilot-mode-active .card:hover {
            border-color: #00ff88;
            box-shadow: 0 20px 60px rgba(0,255,136,0.2), 0 0 30px rgba(0,255,136,0.15);
        }
        
        body.pilot-mode-active .chat-container {
            border-color: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.15);
        }
        
        body.pilot-mode-active .input-container {
            border-color: rgba(0, 255, 136, 0.4);
        }
        
        body.pilot-mode-active .voice-btn {
            background: linear-gradient(135deg, #00ff88, #00cc6a) !important;
            animation: pilotVoicePulse 1.5s infinite;
        }
        
        @keyframes pilotVoicePulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 35px rgba(0, 255, 136, 0.8); }
        }
        
        body.pilot-mode-active h1 {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            -webkit-background-clip: text;
            background-clip: text;
        }
        
        body.pilot-mode-active .scan-line {
            background: linear-gradient(90deg, transparent, #00ff88, transparent);
        }
        
        /* PILOT MODE AVATAR - Green glow and special animations */
        body.pilot-mode-active .avatar {
            background: linear-gradient(135deg, #00ff88, #00cc6a) !important;
            box-shadow: 
                0 0 60px rgba(0, 255, 136, 0.8),
                0 0 100px rgba(0, 255, 136, 0.4),
                0 0 150px rgba(0, 255, 136, 0.2),
                inset 0 0 30px rgba(255, 255, 255, 0.2) !important;
            animation: pilotAvatarMegaPulse 2s ease-in-out infinite !important;
        }
        
        body.pilot-mode-active .avatar::before {
            content: 'üöÄ';
            position: absolute;
            font-size: 0.5em;
            top: -10px;
            right: -10px;
            animation: pilotRocketOrbit 3s linear infinite;
        }
        
        body.pilot-mode-active .avatar::after {
            border-color: #00ff88 !important;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            animation: pilotAvatarRingExpand 1.5s ease-out infinite !important;
        }
        
        @keyframes pilotAvatarMegaPulse {
            0%, 100% { 
                transform: translateY(0) scale(1);
                box-shadow: 
                    0 0 60px rgba(0, 255, 136, 0.8),
                    0 0 100px rgba(0, 255, 136, 0.4);
            }
            50% { 
                transform: translateY(-10px) scale(1.05);
                box-shadow: 
                    0 0 80px rgba(0, 255, 136, 1),
                    0 0 120px rgba(0, 255, 136, 0.6),
                    0 0 180px rgba(0, 255, 136, 0.3);
            }
        }
        
        @keyframes pilotRocketOrbit {
            0% { transform: rotate(0deg) translateX(35px) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(35px) rotate(-360deg); }
        }
        
        @keyframes pilotAvatarRingExpand {
            0% { transform: scale(1); opacity: 1; border-width: 3px; }
            50% { transform: scale(1.3); opacity: 0.5; border-width: 2px; }
            100% { transform: scale(1.6); opacity: 0; border-width: 1px; }
        }
        
        /* Pilot Mode Status Indicator */
        .pilot-status-indicator {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.1));
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 12px 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            color: #00ff88;
            z-index: 1000;
            animation: pilotIndicatorPulse 2s infinite;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        
        body.pilot-mode-active .pilot-status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .pilot-status-indicator .pilot-dot {
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            animation: pilotDotBlink 1s infinite;
        }
        
        @keyframes pilotIndicatorPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); }
            50% { box-shadow: 0 0 50px rgba(0, 255, 136, 0.5); }
        }
        
        @keyframes pilotDotBlink {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .header-status-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .card {
            background: var(--dark-card);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid var(--glass-border);
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent);
            transition: left 0.5s;
        }
        
        .card:hover::before {
            left: 100%;
        }
        
        .card:hover {
            transform: translateY(-5px);
            border-color: var(--neon-cyan);
            box-shadow: 0 20px 60px rgba(0,245,255,0.15), 0 0 30px rgba(0,245,255,0.1);
        }
        
        .card h2 {
            font-family: 'Orbitron', monospace;
            font-size: 1.2em;
            margin-bottom: 20px;
            color: var(--neon-cyan);
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .metric {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border-left: 3px solid var(--neon-cyan);
        }
        
        .metric-label {
            font-size: 0.85em;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-family: 'Orbitron', monospace;
            font-size: 2.2em;
            font-weight: 700;
            background: linear-gradient(135deg, #fff, var(--neon-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta));
            transition: width 0.5s ease;
            box-shadow: 0 0 20px var(--neon-cyan);
            position: relative;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            width: 20px;
            height: 100%;
            background: linear-gradient(90deg, transparent, #fff);
            animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        .chat-container {
            background: var(--dark-card);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            border: 1px solid var(--glass-border);
            min-height: 500px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        .chat-container::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(128,0,255,0.1) 0%, transparent 60%);
            pointer-events: none;
        }
        
        .chat-container h2 {
            font-family: 'Orbitron', monospace;
            color: var(--neon-cyan);
            letter-spacing: 3px;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            border: 1px solid rgba(0,245,255,0.1);
            scrollbar-width: thin;
            scrollbar-color: var(--neon-cyan) transparent;
        }
        
        .messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .messages::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .messages::-webkit-scrollbar-thumb {
            background: var(--neon-cyan);
            border-radius: 3px;
        }
        
        /* ========== STEP 10.4: WHATSAPP-STYLE CHAT ========== */
        .message {
            margin: 8px 0;
            padding: 0;
            max-width: 80%;
            position: relative;
            animation: messageSlide 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            word-wrap: break-word;
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }
        
        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        /* User message (right side) - WhatsApp style */
        .message.user {
            margin-left: auto;
            flex-direction: row-reverse;
        }
        
        .message.user .message-bubble {
            background: linear-gradient(135deg, #0080ff, #6040ff);
            border-radius: 18px 18px 4px 18px;
            padding: 10px 14px;
            box-shadow: 0 2px 10px rgba(0, 128, 255, 0.3);
            position: relative;
        }
        
        /* User bubble tail */
        .message.user .message-bubble::after {
            content: '';
            position: absolute;
            right: -6px;
            bottom: 0;
            width: 12px;
            height: 12px;
            background: #6040ff;
            clip-path: polygon(0 0, 100% 100%, 0 100%);
        }
        
        /* Gideon message (left side) - WhatsApp style */
        .message.gideon {
            margin-right: auto;
        }
        
        .message.gideon .message-bubble,
        .message.gideon .message-text {
            background: linear-gradient(135deg, rgba(20, 25, 40, 0.95), rgba(30, 35, 55, 0.95));
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 18px 18px 18px 4px;
            padding: 10px 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        /* Gideon bubble tail */
        .message.gideon .message-bubble::before,
        .message.gideon .message-text::before {
            content: '';
            position: absolute;
            left: -6px;
            bottom: 0;
            width: 12px;
            height: 12px;
            background: rgba(30, 35, 55, 0.95);
            clip-path: polygon(100% 0, 100% 100%, 0 100%);
        }
        
        /* Message content wrapper */
        .message-content {
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        
        /* WhatsApp-style avatar */
        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 0.9em;
            flex-shrink: 0;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.4);
            border: 2px solid rgba(0, 245, 255, 0.3);
        }
        
        /* Avatar speaking animation */
        .message-avatar.speaking {
            animation: avatarSpeaking 0.5s ease-in-out infinite;
        }
        
        @keyframes avatarSpeaking {
            0%, 100% { transform: scale(1); box-shadow: 0 0 15px rgba(0, 245, 255, 0.4); }
            50% { transform: scale(1.1); box-shadow: 0 0 25px rgba(0, 245, 255, 0.7); }
        }
        
        /* User avatar */
        .message.user .message-avatar {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-magenta));
            box-shadow: 0 0 15px rgba(128, 0, 255, 0.4);
            border-color: rgba(128, 0, 255, 0.3);
        }
        
        /* Message text styling */
        .message-bubble .message-text-content,
        .message .text-content {
            line-height: 1.5;
            font-size: 0.95em;
        }
        
        /* WhatsApp-style timestamp and checks */
        .message-meta {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
            margin-top: 4px;
            font-size: 0.7em;
            opacity: 0.6;
            font-family: 'Orbitron', monospace;
        }
        
        .message-timestamp {
            letter-spacing: 1px;
        }
        
        /* Double check marks (WhatsApp style) */
        .message-checks {
            display: flex;
            align-items: center;
            font-size: 1.1em;
            margin-left: 3px;
            transition: all 0.3s ease;
        }
        
        .message-checks.sent { color: rgba(255, 255, 255, 0.4); }
        .message-checks.delivered { color: rgba(255, 255, 255, 0.7); }
        .message-checks.read { 
            color: var(--neon-cyan); 
            text-shadow: 0 0 8px var(--neon-cyan);
        }
        
        /* ========== FEEDBACK BUTTONS ========== */
        .message-feedback {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .message:hover .message-feedback,
        .message-feedback.visible {
            opacity: 1;
        }
        
        .feedback-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .feedback-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .feedback-btn.thumbs-up:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }
        
        .feedback-btn.thumbs-down:hover {
            background: rgba(255, 100, 100, 0.15);
            border-color: rgba(255, 100, 100, 0.4);
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.3);
        }
        
        .feedback-btn.selected {
            opacity: 1;
        }
        
        .feedback-btn.thumbs-up.selected {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
        }
        
        .feedback-btn.thumbs-down.selected {
            background: rgba(255, 100, 100, 0.25);
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.4);
        }
        
        .feedback-btn:disabled {
            pointer-events: none;
            opacity: 0.3;
        }
        
        .feedback-thanks {
            font-size: 0.7em;
            color: rgba(0, 255, 136, 0.7);
            font-family: 'Rajdhani', sans-serif;
            margin-left: 8px;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        /* ========== LEARNING INDICATOR ========== */
        .learning-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: linear-gradient(135deg, rgba(255, 200, 0, 0.15), rgba(255, 150, 0, 0.1));
            border: 1px solid rgba(255, 200, 0, 0.4);
            border-radius: 30px;
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 40px rgba(255, 200, 0, 0.2);
            backdrop-filter: blur(15px);
        }
        
        .learning-indicator.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        
        .learning-icon {
            font-size: 1.3em;
            animation: lightbulbPulse 1s ease-in-out infinite;
        }
        
        @keyframes lightbulbPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.3); }
        }
        
        .learning-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .learning-text strong {
            color: #ffc800;
            text-shadow: 0 0 10px rgba(255, 200, 0, 0.5);
        }
        
        /* ========== MINI HOLOGRAM AVATAR IN CHAT ========== */
        .message-avatar.hologram-mini {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: linear-gradient(135deg, rgba(26, 26, 62, 0.9), rgba(10, 10, 31, 0.95));
            border: 2px solid rgba(0, 245, 255, 0.4);
            flex-shrink: 0;
            overflow: hidden;
        }
        
        .message-avatar.hologram-mini .avatar-letter {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 0.9em;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            z-index: 2;
        }
        
        .message-avatar.hologram-mini .mini-scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(0, 245, 255, 0.05) 2px,
                rgba(0, 245, 255, 0.05) 3px
            );
            pointer-events: none;
            z-index: 3;
        }
        
        .message-avatar.hologram-mini::before {
            content: '';
            position: absolute;
            top: -50%;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(180deg, rgba(0, 245, 255, 0.2) 0%, transparent 100%);
            animation: miniHologramScan 2s linear infinite;
            z-index: 4;
        }
        
        .message-avatar.hologram-mini.speaking {
            animation: miniAvatarSpeak 0.3s ease-in-out infinite;
            border-color: rgba(128, 0, 255, 0.6);
            box-shadow: 0 0 20px rgba(128, 0, 255, 0.5);
        }
        
        .message-avatar.hologram-mini.speaking .avatar-letter {
            color: var(--neon-magenta);
            text-shadow: 0 0 10px var(--neon-magenta);
        }
        
        @keyframes miniHologramScan {
            0% { top: -50%; }
            100% { top: 150%; }
        }
        
        @keyframes miniAvatarSpeak {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        /* Level badge in messages */
        .level-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.65em;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            margin-left: 8px;
            text-transform: uppercase;
        }
        
        .level-badge.advanced {
            background: rgba(128, 0, 255, 0.2);
            color: var(--neon-purple);
            border: 1px solid rgba(128, 0, 255, 0.4);
        }
        
        .level-badge.pilot {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.4);
            animation: pilotBadgeGlow 2s ease-in-out infinite;
        }
        
        @keyframes pilotBadgeGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.3); }
            50% { box-shadow: 0 0 10px rgba(0, 255, 136, 0.6); }
        }
        
        /* Date separator */
        .date-separator {
            text-align: center;
            margin: 20px 0;
            position: relative;
        }
        
        .date-separator span {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Orbitron', monospace;
            letter-spacing: 1px;
        }
        
        /* Typing indicator bubble */
        .typing-bubble {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(20, 25, 40, 0.95), rgba(30, 35, 55, 0.95));
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 18px 18px 18px 4px;
            max-width: fit-content;
        }
        
        .typing-bubble .typing-dots {
            display: flex;
            gap: 4px;
        }
        
        .typing-bubble .typing-dots span {
            width: 8px;
            height: 8px;
            background: var(--neon-cyan);
            border-radius: 50%;
            animation: typingDot 1.4s infinite ease-in-out;
        }
        
        .typing-bubble .typing-dots span:nth-child(1) { animation-delay: 0s; }
        .typing-bubble .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-bubble .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingDot {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; }
            40% { transform: scale(1); opacity: 1; }
        }
        
        /* Voice message style */
        .voice-message-bubble {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 200px;
        }
        
        .voice-waveform {
            flex: 1;
            height: 30px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .voice-waveform .wave-bar {
            width: 3px;
            background: var(--neon-cyan);
            border-radius: 2px;
            opacity: 0.6;
        }
        
        .voice-waveform.playing .wave-bar {
            animation: waveformPlay 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes waveformPlay {
            0% { height: 5px; }
            100% { height: 25px; }
        }
        
        .voice-duration {
            font-size: 0.8em;
            font-family: 'Orbitron', monospace;
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* Legacy support - keep existing classes working */
        .message.user {
            text-align: left;
        }
        
        .message.gideon {
            border: none;
            box-shadow: none;
        }
        
        /* ========== GIDEON 3.0 Message Styles ========== */
        .message.advanced-message {
            background: linear-gradient(135deg, rgba(0, 80, 120, 0.95), rgba(0, 40, 80, 0.95));
            border: 1px solid rgba(0, 200, 255, 0.4);
            box-shadow: 0 4px 20px rgba(0, 200, 255, 0.3);
        }
        
        .cognitive-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.8em;
            border: 1px solid rgba(0, 200, 255, 0.2);
        }
        
        .cognitive-header {
            font-family: 'Orbitron', monospace;
            color: var(--neon-cyan);
            font-size: 0.85em;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }
        
        .cognitive-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .cog-label { color: #888; }
        .cog-value { color: var(--neon-cyan); font-family: 'Orbitron', monospace; }
        
        .message.confirmation-message {
            background: linear-gradient(135deg, rgba(120, 80, 0, 0.95), rgba(80, 50, 0, 0.95));
            border: 1px solid rgba(255, 180, 0, 0.4);
        }
        
        .confirmation-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .confirm-btn, .reject-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .confirm-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .confirm-btn:hover { transform: scale(1.05); box-shadow: 0 0 15px rgba(0,255,136,0.5); }
        
        .reject-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }
        
        .reject-btn:hover { transform: scale(1.05); box-shadow: 0 0 15px rgba(255,0,0,0.5); }
        
        .message.suggestion-message {
            background: linear-gradient(135deg, rgba(80, 0, 120, 0.95), rgba(40, 0, 80, 0.95));
            border: 1px solid rgba(180, 100, 255, 0.4);
        }
        
        .suggestion-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .suggest-btn {
            background: rgba(180, 100, 255, 0.2);
            border: 1px solid rgba(180, 100, 255, 0.4);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s;
        }
        
        .suggest-btn:hover {
            background: rgba(180, 100, 255, 0.4);
            transform: translateX(5px);
        }
        
        /* Pilot mode message styling */
        .message.pilot-message {
            background: linear-gradient(135deg, rgba(0, 40, 30, 0.95), rgba(0, 60, 45, 0.95));
            border: 1px solid rgba(0, 255, 136, 0.4);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3), 0 0 30px rgba(0, 255, 136, 0.1);
            animation: pilotMessageGlow 2s ease-in-out infinite;
        }
        
        @keyframes pilotMessageGlow {
            0%, 100% { box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3), 0 0 30px rgba(0, 255, 136, 0.1); }
            50% { box-shadow: 0 4px 30px rgba(0, 255, 136, 0.5), 0 0 40px rgba(0, 255, 136, 0.2); }
        }
        
        /* ========== STEP 9: Thinking/Reasoning message styling ========== */
        .message.thinking-message {
            background: linear-gradient(135deg, rgba(80, 0, 120, 0.3), rgba(40, 0, 80, 0.4));
            border: 1px solid rgba(200, 100, 255, 0.4);
            box-shadow: 0 4px 20px rgba(180, 80, 255, 0.2);
        }
        
        .thinking-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(200, 100, 255, 0.3);
        }
        
        .thinking-icon {
            font-size: 1.4em;
            animation: thinkingPulse 2s infinite;
        }
        
        @keyframes thinkingPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .thinking-title {
            font-family: 'Orbitron', monospace;
            font-size: 0.85em;
            font-weight: bold;
            color: var(--neon-purple);
            letter-spacing: 2px;
        }
        
        .thinking-metrics {
            display: flex;
            gap: 15px;
            font-size: 0.75em;
            opacity: 0.8;
            margin-bottom: 12px;
            font-family: 'Orbitron', monospace;
        }
        
        .thinking-metrics span {
            background: rgba(180, 80, 255, 0.2);
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        .thinking-response {
            line-height: 1.6;
            margin: 10px 0;
        }
        
        .thinking-confidence {
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            margin-top: 12px;
            padding: 5px 10px;
            border-radius: 15px;
            display: inline-block;
        }
        
        .thinking-confidence.high {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .thinking-confidence.medium {
            background: rgba(255, 200, 0, 0.2);
            color: #ffc800;
        }
        
        .thinking-confidence.low {
            background: rgba(255, 100, 100, 0.2);
            color: #ff6464;
        }
        
        .thinking-avatar {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-magenta)) !important;
            animation: thinkingAvatarPulse 2s infinite;
        }
        
        @keyframes thinkingAvatarPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(180, 80, 255, 0.5); }
            50% { box-shadow: 0 0 25px rgba(180, 80, 255, 0.8); }
        }
        
        .pilot-avatar {
            background: linear-gradient(135deg, #00ff88, #00cc6a) !important;
            animation: pilotAvatarPulse 1.5s infinite;
        }
        
        @keyframes pilotAvatarPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 136, 0.5); transform: scale(1); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 136, 0.8); transform: scale(1.05); }
        }
        
        .message-time {
            font-family: 'Orbitron', monospace;
            font-size: 0.65em;
            opacity: 0.5;
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
            letter-spacing: 1px;
        }
        
        .message.user .message-time {
            justify-content: flex-end;
        }
        
        .message-check {
            font-size: 0.8em;
            color: rgba(255,255,255,0.4);
            transition: all 0.3s ease;
        }
        
        .message-check.delivered {
            color: rgba(255,255,255,0.6);
        }
        
        .message-check.seen {
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        
        .level-badge {
            font-size: 0.7em;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
            font-family: 'Orbitron', monospace;
            letter-spacing: 1px;
        }
        
        .level-badge.advanced {
            background: rgba(128, 0, 255, 0.3);
            border: 1px solid var(--neon-purple);
            color: var(--neon-purple);
        }
        
        .level-badge.pilot {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            animation: pilotBadgePulse 2s infinite;
        }
        
        @keyframes pilotBadgePulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 136, 0.5); }
        }
        
        /* Pilot Data Panels */
        .pilot-data-panel {
            margin-top: 12px;
            padding: 12px;
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .pilot-data-panel.full-control {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 200, 100, 0.05));
            border: 1px solid rgba(0, 255, 136, 0.4);
            animation: fullControlGlow 3s infinite;
        }
        
        @keyframes fullControlGlow {
            0%, 100% { box-shadow: inset 0 0 20px rgba(0, 255, 136, 0.1); }
            50% { box-shadow: inset 0 0 30px rgba(0, 255, 136, 0.2); }
        }
        
        .pilot-data-header {
            font-family: 'Orbitron', monospace;
            font-size: 0.75em;
            color: #00ff88;
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        .pilot-data-steps {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .pilot-step {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            background: rgba(0, 255, 136, 0.05);
            border-radius: 4px;
        }
        
        .pilot-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .pilot-metric {
            display: flex;
            flex-direction: column;
            padding: 8px;
            background: rgba(0, 255, 136, 0.08);
            border-radius: 6px;
        }
        
        .metric-label {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: capitalize;
        }
        
        .metric-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.1em;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .pilot-decisions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .pilot-decision {
            padding: 8px;
            border-radius: 6px;
            font-size: 0.85em;
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        
        .pilot-decision.critica {
            background: rgba(255, 0, 0, 0.15);
            border-left: 3px solid #ff4444;
        }
        
        .pilot-decision.alta {
            background: rgba(255, 136, 0, 0.15);
            border-left: 3px solid #ff8800;
        }
        
        .pilot-decision.media {
            background: rgba(255, 255, 0, 0.1);
            border-left: 3px solid #ffcc00;
        }
        
        .pilot-decision.info {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
        }
        
        .decision-area {
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
        }
        
        .decision-text {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .pilot-control-status {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 6px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .control-icon {
            font-size: 1.1em;
        }
        
        .pilot-confirmation-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
            padding: 4px 12px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.7em;
            letter-spacing: 1px;
        }
        
        .pilot-confirmation-badge.approved {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }
        
        .pilot-confirmation-badge.denied {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }
        
        .conf-confidence {
            opacity: 0.7;
        }
        
        /* ========== STEP 9: Auto-executed actions styling ========== */
        .pilot-data-panel.auto-actions {
            background: linear-gradient(135deg, rgba(0, 136, 255, 0.1), rgba(0, 200, 255, 0.05));
            border: 1px solid rgba(0, 200, 255, 0.3);
        }
        
        .pilot-actions-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .pilot-action-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(0, 200, 255, 0.1);
            border-radius: 6px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .action-check {
            color: #00ff88;
        }
        
        .action-desc {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .reasoning-complete-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
            padding: 4px 12px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.65em;
            letter-spacing: 1px;
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.5);
            color: #9d6bff;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            font-weight: bold;
            margin-right: 10px;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
            flex-shrink: 0;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.4);
            animation: avatarGlow 2s ease-in-out infinite;
        }
        
        @keyframes avatarGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 245, 255, 0.4); }
            50% { box-shadow: 0 0 25px rgba(0, 245, 255, 0.6); }
        }
        
        .message-content {
            display: flex;
            align-items: flex-start;
        }
        
        .message-text {
            flex: 1;
            line-height: 1.5;
        }
        
        .typing-indicator {
            display: none;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(20, 25, 40, 0.95), rgba(30, 35, 55, 0.95));
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 18px 18px 18px 4px;
            max-width: 220px;
            margin: 12px 0;
            animation: fadeInUp 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .typing-indicator.show {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .typing-avatar-mini {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(26, 26, 62, 0.9), rgba(10, 10, 31, 0.95));
            border: 2px solid rgba(0, 245, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }
        
        .typing-avatar-letter {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 0.8em;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        
        .typing-avatar-pulse {
            position: absolute;
            inset: -4px;
            border-radius: 50%;
            border: 2px solid rgba(0, 245, 255, 0.3);
            animation: typingPulse 1.5s infinite;
        }
        
        @keyframes typingPulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 0; }
        }
        
        .typing-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .typing-name {
            font-family: 'Orbitron', monospace;
            font-size: 0.7em;
            color: var(--neon-cyan);
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        .typing-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .typing-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.7);
            font-style: italic;
        }
        
        .typing-dots {
            display: flex;
            gap: 3px;
        }
        
        .typing-dots span {
            width: 5px;
            height: 5px;
            background: var(--neon-cyan);
            border-radius: 50%;
            animation: typingBounce 1.4s infinite;
            box-shadow: 0 0 6px var(--neon-cyan);
        }
        
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingBounce {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
            30% { transform: translateY(-4px); opacity: 1; }
        }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideInFromLeft {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes slideInFromRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message {
            animation: fadeInUp 0.3s ease-out;
        }

        .message.gideon {
            animation: slideInFromLeft 0.4s ease-out;
        }

        .message.user {
            animation: slideInFromRight 0.3s ease-out;
        }
        
        .input-container {
            display: flex;
            gap: 12px;
            padding: 15px;
            background: rgba(15, 15, 25, 0.9);
            border-radius: 30px;
            margin-top: 15px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        input[type="text"] {
            flex: 1;
            padding: 14px 24px;
            border: none;
            border-radius: 25px;
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            font-size: 1em;
            font-family: 'Rajdhani', sans-serif;
            border: 1px solid transparent;
            transition: all 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2);
        }
        
        input[type="text"]::placeholder {
            color: rgba(255,255,255,0.4);
            font-family: 'Rajdhani', sans-serif;
        }
        
        button {
            padding: 14px 32px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
            color: #000;
            font-size: 1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: 'Orbitron', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 10px 30px rgba(0, 245, 255, 0.4), 0 0 20px rgba(0, 245, 255, 0.2);
        }
        
        button:active {
            transform: translateY(0) scale(0.98);
        }
        
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(50%);
        }
        
        .quick-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .quick-btn {
            padding: 10px 20px;
            font-size: 0.85em;
            background: linear-gradient(135deg, rgba(0, 128, 255, 0.3), rgba(128, 0, 255, 0.3));
            border: 1px solid rgba(0, 245, 255, 0.3);
            color: #fff;
        }
        
        .quick-btn:hover {
            background: linear-gradient(135deg, rgba(0, 128, 255, 0.6), rgba(128, 0, 255, 0.6));
            border-color: var(--neon-cyan);
        }
        
        /* ========== ACTIONS PANEL ========== */
        .actions-card {
            grid-column: span 2;
        }
        
        .actions-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .action-tab {
            flex: 1;
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid rgba(0, 245, 255, 0.3);
            color: var(--neon-cyan);
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .action-tab:hover, .action-tab.active {
            background: rgba(0, 245, 255, 0.3);
            border-color: var(--neon-cyan);
        }
        
        .action-panel {
            display: none;
        }
        
        .action-panel.active {
            display: block;
        }
        
        .action-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .action-btn .action-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .action-btn .action-label {
            font-family: 'Orbitron', monospace;
            font-size: 0.6rem;
            color: #fff;
            text-align: center;
        }
        
        .action-btn .action-level {
            position: absolute;
            top: 3px;
            right: 3px;
            font-size: 0.5rem;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Orbitron', monospace;
        }
        
        .action-btn.safe {
            border-color: rgba(0, 245, 255, 0.4);
        }
        
        .action-btn.safe:hover {
            background: rgba(0, 245, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }
        
        .action-btn.elevated {
            border-color: rgba(255, 170, 0, 0.5);
        }
        
        .action-btn.elevated .action-level {
            background: rgba(255, 170, 0, 0.5);
            color: #fff;
        }
        
        .action-btn.elevated:hover {
            background: rgba(255, 170, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.3);
        }
        
        .action-btn.critical {
            border-color: rgba(0, 255, 136, 0.5);
        }
        
        .action-btn.critical .action-level {
            background: rgba(0, 255, 136, 0.5);
            color: #000;
        }
        
        .action-btn.critical:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        .action-btn.destructive {
            border-color: rgba(255, 50, 50, 0.5);
        }
        
        .action-btn.destructive .action-level {
            background: rgba(255, 50, 50, 0.5);
            color: #fff;
        }
        
        .action-btn.destructive:hover {
            background: rgba(255, 50, 50, 0.2);
            box-shadow: 0 0 15px rgba(255, 50, 50, 0.3);
        }
        
        /* Routines List */
        .routines-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .routine-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 5px;
            margin-bottom: 8px;
        }
        
        .routine-info {
            flex: 1;
        }
        
        .routine-name {
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            color: var(--neon-cyan);
        }
        
        .routine-schedule {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .routine-toggle {
            width: 40px;
            height: 20px;
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .routine-toggle.enabled {
            background: rgba(0, 255, 136, 0.5);
        }
        
        .routine-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
        }
        
        .routine-toggle.enabled::after {
            left: 22px;
        }
        
        /* Action Logs */
        .action-logs-list {
            max-height: 180px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        .action-log-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid;
            margin-bottom: 5px;
            font-size: 0.7rem;
        }
        
        .action-log-item.success {
            border-color: #00ff88;
        }
        
        .action-log-item.failed {
            border-color: #ff5050;
        }
        
        .action-log-item.pending, .action-log-item.running {
            border-color: #ffaa00;
        }
        
        .log-time {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.6rem;
        }
        
        .log-action {
            flex: 1;
            color: #fff;
        }
        
        .log-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.55rem;
            font-family: 'Orbitron', monospace;
        }
        
        .log-status.success {
            background: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .log-status.failed {
            background: rgba(255, 50, 50, 0.3);
            color: #ff5050;
        }
        
        .logs-actions {
            display: flex;
            gap: 10px;
        }
        
        .refresh-btn, .rollback-btn {
            flex: 1;
            padding: 8px;
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid rgba(0, 245, 255, 0.3);
            color: var(--neon-cyan);
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .rollback-btn {
            background: rgba(255, 170, 0, 0.1);
            border-color: rgba(255, 170, 0, 0.3);
            color: #ffaa00;
        }
        
        .rollback-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .refresh-btn:hover, .rollback-btn:hover:not(:disabled) {
            background: rgba(0, 245, 255, 0.3);
        }
        
        .loading-routines, .loading-logs {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            padding: 20px;
            font-size: 0.8rem;
        }
        
        @media (max-width: 768px) {
            .action-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .actions-card {
                grid-column: span 1;
            }
        }
        
        /* ========== AVATAR 3D - HOLOGRAM STYLE (The Flash Gideon) ========== */
        .avatar-3d-container {
            width: 120px;
            height: 120px;
            margin: 0 auto 10px;
            perspective: 800px;
            position: relative;
        }
        
        /* ========== HOLOGRAM EFFECT - THE FLASH GIDEON STYLE ========== */
        .avatar-3d-container::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 160px;
            height: 200px;
            background: linear-gradient(180deg, 
                rgba(0, 245, 255, 0) 0%,
                rgba(0, 245, 255, 0.03) 20%,
                rgba(0, 245, 255, 0.08) 40%,
                rgba(0, 245, 255, 0.03) 80%,
                rgba(0, 245, 255, 0) 100%);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            pointer-events: none;
            animation: hologramFlicker 3s ease-in-out infinite;
            z-index: -1;
        }
        
        /* Hologram projection base */
        .avatar-3d-container::after {
            content: '';
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 10px;
            background: radial-gradient(ellipse, rgba(0, 245, 255, 0.4) 0%, transparent 70%);
            filter: blur(3px);
            animation: projectorBase 2s ease-in-out infinite;
        }
        
        /* Hologram scanlines overlay */
        .hologram-scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            z-index: 10;
        }
        
        .hologram-scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(0, 245, 255, 0.03) 2px,
                rgba(0, 245, 255, 0.03) 4px
            );
            animation: scanlineMove 8s linear infinite;
        }
        
        .hologram-scanlines::after {
            content: '';
            position: absolute;
            top: -100%;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(180deg, 
                rgba(0, 245, 255, 0.15) 0%, 
                transparent 100%);
            animation: hologramScan 4s linear infinite;
        }
        
        /* Hologram glitch effect */
        .hologram-glitch {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            z-index: 11;
            opacity: 0;
            animation: glitchTrigger 8s infinite;
        }
        
        .hologram-glitch::before {
            content: '';
            position: absolute;
            top: 0;
            left: -5px;
            width: 110%;
            height: 100%;
            background: rgba(255, 0, 100, 0.1);
            clip-path: polygon(0 10%, 100% 15%, 100% 20%, 0 18%);
        }
        
        .hologram-glitch::after {
            content: '';
            position: absolute;
            top: 0;
            right: -5px;
            width: 110%;
            height: 100%;
            background: rgba(0, 255, 255, 0.1);
            clip-path: polygon(0 60%, 100% 58%, 100% 65%, 0 62%);
        }
        
        @keyframes hologramFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
            95% { opacity: 0.9; }
            96% { opacity: 1; }
        }
        
        @keyframes projectorBase {
            0%, 100% { opacity: 0.6; transform: translateX(-50%) scaleX(1); }
            50% { opacity: 0.9; transform: translateX(-50%) scaleX(1.1); }
        }
        
        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }
        
        @keyframes hologramScan {
            0% { top: -50%; }
            100% { top: 150%; }
        }
        
        @keyframes glitchTrigger {
            0%, 89%, 91%, 100% { opacity: 0; }
            90% { opacity: 1; transform: translateX(2px); }
        }
        
        /* Hologram transparency effect on head */
        .avatar-3d-head {
            background: linear-gradient(135deg, 
                rgba(26, 26, 62, 0.85) 0%, 
                rgba(10, 10, 31, 0.9) 100%) !important;
            backdrop-filter: blur(5px);
        }
        
        /* Hologram data stream particles */
        .hologram-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            z-index: 5;
        }
        
        .hologram-particles::before,
        .hologram-particles::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--neon-cyan);
            border-radius: 50%;
            box-shadow: 0 0 6px var(--neon-cyan);
            animation: particleFloat 3s linear infinite;
        }
        
        .hologram-particles::before {
            left: 20%;
            animation-delay: 0s;
        }
        
        .hologram-particles::after {
            left: 70%;
            animation-delay: 1.5s;
        }
        
        @keyframes particleFloat {
            0% { bottom: 0; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { bottom: 100%; opacity: 0; }
        }
        
        /* Avatar State Indicator */
        .avatar-state-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            letter-spacing: 2px;
            color: var(--neon-cyan);
            text-transform: uppercase;
        }
        
        .avatar-state-indicator .state-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--neon-cyan);
            box-shadow: 0 0 10px var(--neon-cyan);
            animation: stateDotPulse 1.5s ease-in-out infinite;
        }
        
        .avatar-state-indicator.listening .state-dot {
            background: #00f5ff;
            box-shadow: 0 0 15px #00f5ff;
        }
        
        .avatar-state-indicator.speaking .state-dot {
            background: #8000ff;
            box-shadow: 0 0 15px #8000ff;
            animation: stateDotPulse 0.3s ease-in-out infinite;
        }
        
        .avatar-state-indicator.thinking .state-dot {
            background: #ffaa00;
            box-shadow: 0 0 15px #ffaa00;
        }
        
        .avatar-state-indicator.pilot .state-dot {
            background: #00ff88;
            box-shadow: 0 0 15px #00ff88;
        }
        
        @keyframes stateDotPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.8); }
        }
        
        .avatar-3d {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            animation: avatar3DFloat 4s ease-in-out infinite;
        }
        
        .avatar-3d-head {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #1a1a3e 0%, #0a0a1f 100%);
            position: relative;
            transform-style: preserve-3d;
            box-shadow: 
                0 0 60px rgba(0, 245, 255, 0.4),
                0 0 100px rgba(0, 245, 255, 0.2),
                inset 0 -20px 40px rgba(0, 0, 0, 0.5),
                inset 0 20px 40px rgba(0, 245, 255, 0.1);
            border: 2px solid rgba(0, 245, 255, 0.3);
            overflow: hidden;
            /* Smooth transitions between states */
            transition: box-shadow 0.5s ease, background 0.5s ease, border-color 0.5s ease;
        }
        
        /* Face plate - holographic effect */
        .avatar-3d-face {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
        }
        
        /* Eyes */
        .avatar-3d-eyes {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 25px;
        }
        
        .avatar-3d-eye {
            width: 18px;
            height: 18px;
            background: radial-gradient(circle at 30% 30%, #00f5ff, #0080ff);
            border-radius: 50%;
            position: relative;
            box-shadow: 
                0 0 15px rgba(0, 245, 255, 0.8),
                0 0 30px rgba(0, 245, 255, 0.4);
            animation: eyeGlow 2s ease-in-out infinite;
            /* Smooth transitions between states */
            transition: background 0.4s ease, box-shadow 0.4s ease;
        }
        
        .avatar-3d-eye::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
            opacity: 0.8;
        }
        
        .avatar-3d-eye::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #001a33;
            border-radius: 50%;
            animation: pupilMove 4s ease-in-out infinite;
        }
        
        @keyframes eyeGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 245, 255, 0.8), 0 0 30px rgba(0, 245, 255, 0.4); }
            50% { box-shadow: 0 0 25px rgba(0, 245, 255, 1), 0 0 50px rgba(0, 245, 255, 0.6); }
        }
        
        @keyframes pupilMove {
            0%, 100% { transform: translate(-50%, -50%); }
            25% { transform: translate(-30%, -50%); }
            50% { transform: translate(-50%, -30%); }
            75% { transform: translate(-70%, -50%); }
        }
        
        /* Blink animation */
        .avatar-3d-eye.blinking {
            animation: blink 0.15s ease-in-out;
        }
        
        @keyframes blink {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.1); }
        }
        
        /* Mouth / Lip sync */
        .avatar-3d-mouth {
            position: absolute;
            bottom: 28%;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 8px;
            background: linear-gradient(180deg, #00f5ff, #0080ff);
            border-radius: 0 0 15px 15px;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.6);
            transition: all 0.1s ease;
        }
        
        /* Lip sync animation states */
        .avatar-3d-mouth.speaking {
            animation: lipSync 0.15s ease-in-out infinite;
        }
        
        @keyframes lipSync {
            0%, 100% { 
                height: 8px; 
                width: 30px;
                border-radius: 0 0 15px 15px;
            }
            25% { 
                height: 14px; 
                width: 24px;
                border-radius: 50%;
            }
            50% { 
                height: 18px; 
                width: 20px;
                border-radius: 50%;
            }
            75% { 
                height: 12px; 
                width: 28px;
                border-radius: 0 0 15px 15px;
            }
        }
        
        /* Idle mouth animation */
        .avatar-3d-mouth.idle {
            animation: mouthIdle 4s ease-in-out infinite;
        }
        
        @keyframes mouthIdle {
            0%, 100% { width: 30px; opacity: 0.8; }
            50% { width: 32px; opacity: 1; }
        }
        
        /* Circuit lines decoration */
        .avatar-3d-circuits {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
        }
        
        .avatar-3d-circuits::before,
        .avatar-3d-circuits::after {
            content: '';
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(0, 245, 255, 0.3), transparent);
            height: 1px;
        }
        
        .avatar-3d-circuits::before {
            top: 20%;
            left: 0;
            width: 40%;
            animation: circuitPulse 3s ease-in-out infinite;
        }
        
        .avatar-3d-circuits::after {
            top: 75%;
            right: 0;
            width: 35%;
            animation: circuitPulse 3s ease-in-out infinite 1.5s;
        }
        
        @keyframes circuitPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        /* Outer ring */
        .avatar-3d-ring {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 50%;
            animation: ringRotate 10s linear infinite;
        }
        
        .avatar-3d-ring::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 50%;
            width: 10px;
            height: 10px;
            background: var(--neon-cyan);
            border-radius: 50%;
            box-shadow: 0 0 20px var(--neon-cyan);
        }
        
        @keyframes ringRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Float animation */
        @keyframes avatar3DFloat {
            0%, 100% { transform: translateY(0) rotateX(0) rotateY(0); }
            25% { transform: translateY(-5px) rotateX(2deg) rotateY(3deg); }
            50% { transform: translateY(-8px) rotateX(0) rotateY(-2deg); }
            75% { transform: translateY(-3px) rotateX(-2deg) rotateY(2deg); }
        }
        
        /* Listening state */
        .avatar-3d-container.listening .avatar-3d-head {
            box-shadow: 
                0 0 80px rgba(0, 245, 255, 0.7),
                0 0 120px rgba(0, 245, 255, 0.4),
                inset 0 -20px 40px rgba(0, 0, 0, 0.5),
                inset 0 20px 40px rgba(0, 245, 255, 0.2);
            animation: listeningPulse 1s ease-in-out infinite, listeningHead 3s ease-in-out infinite;
        }
        
        .avatar-3d-container.listening .avatar-3d-eye {
            animation: eyeListening 0.5s ease-in-out infinite;
        }
        
        @keyframes listeningPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        @keyframes listeningHead {
            0%, 100% { transform: rotateX(2deg); }
            50% { transform: rotateX(-2deg); }
        }
        
        @keyframes eyeListening {
            0%, 100% { box-shadow: 0 0 25px rgba(0, 245, 255, 1), 0 0 50px rgba(0, 245, 255, 0.6); }
            50% { box-shadow: 0 0 35px rgba(0, 245, 255, 1), 0 0 70px rgba(0, 245, 255, 0.8); }
        }
        
        /* Speaking state */
        .avatar-3d-container.speaking .avatar-3d-head {
            box-shadow: 
                0 0 100px rgba(128, 0, 255, 0.6),
                0 0 150px rgba(128, 0, 255, 0.3),
                inset 0 -20px 40px rgba(0, 0, 0, 0.5),
                inset 0 20px 40px rgba(128, 0, 255, 0.1);
            animation: speakingHead 0.8s ease-in-out infinite;
        }
        
        .avatar-3d-container.speaking .avatar-3d-eye {
            background: radial-gradient(circle at 30% 30%, #ff00ff, #8000ff);
            box-shadow: 0 0 20px rgba(128, 0, 255, 0.8), 0 0 40px rgba(128, 0, 255, 0.4);
        }
        
        @keyframes speakingHead {
            0%, 100% { transform: rotateY(0deg) rotateX(0deg); }
            25% { transform: rotateY(3deg) rotateX(1deg); }
            50% { transform: rotateY(-2deg) rotateX(-1deg); }
            75% { transform: rotateY(2deg) rotateX(0deg); }
        }
        
        /* Thinking state */
        .avatar-3d-container.thinking .avatar-3d-head {
            box-shadow: 
                0 0 80px rgba(255, 170, 0, 0.6),
                0 0 120px rgba(255, 170, 0, 0.3),
                inset 0 -20px 40px rgba(0, 0, 0, 0.5),
                inset 0 20px 40px rgba(255, 170, 0, 0.1);
            animation: thinkingPulse 2s ease-in-out infinite;
        }
        
        .avatar-3d-container.thinking .avatar-3d-eye {
            background: radial-gradient(circle at 30% 30%, #ffaa00, #ff6600);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.8), 0 0 40px rgba(255, 170, 0, 0.4);
            animation: eyeThinking 2s ease-in-out infinite;
        }
        
        .avatar-3d-container.thinking .avatar-3d-ring {
            border-color: rgba(255, 170, 0, 0.5);
            animation: ringRotate 3s linear infinite;
        }
        
        .avatar-3d-container.thinking .avatar-3d-ring::before {
            background: #ffaa00;
            box-shadow: 0 0 20px #ffaa00;
        }
        
        @keyframes thinkingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        
        @keyframes eyeThinking {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }
        
        /* Pilot mode avatar - special green glow and animations */
        body.pilot-mode-active .avatar-3d-head {
            background: linear-gradient(135deg, #0a2a1a 0%, #001a0a 100%) !important;
            border-color: rgba(0, 255, 136, 0.5) !important;
            box-shadow: 
                0 0 80px rgba(0, 255, 136, 0.6),
                0 0 120px rgba(0, 255, 136, 0.3),
                inset 0 -20px 40px rgba(0, 0, 0, 0.5),
                inset 0 20px 40px rgba(0, 255, 136, 0.1) !important;
            animation: pilotPulse 2s ease-in-out infinite !important;
        }
        
        body.pilot-mode-active .avatar-3d-eye {
            background: radial-gradient(circle at 30% 30%, #00ff88, #00cc6a) !important;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8), 0 0 40px rgba(0, 255, 136, 0.4) !important;
            animation: pilotEyeScan 4s ease-in-out infinite !important;
        }
        
        body.pilot-mode-active .avatar-3d-mouth {
            background: linear-gradient(180deg, #00ff88, #00cc6a) !important;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.6) !important;
        }
        
        body.pilot-mode-active .avatar-3d-ring {
            border-color: rgba(0, 255, 136, 0.4) !important;
            animation: ringRotate 5s linear infinite !important;
        }
        
        body.pilot-mode-active .avatar-3d-ring::before {
            background: #00ff88 !important;
            box-shadow: 0 0 20px #00ff88 !important;
        }
        
        body.pilot-mode-active .avatar-3d-circuits::before,
        body.pilot-mode-active .avatar-3d-circuits::after {
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.6), transparent) !important;
        }
        
        @keyframes pilotPulse {
            0%, 100% { 
                box-shadow: 
                    0 0 80px rgba(0, 255, 136, 0.6),
                    0 0 120px rgba(0, 255, 136, 0.3),
                    inset 0 -20px 40px rgba(0, 0, 0, 0.5),
                    inset 0 20px 40px rgba(0, 255, 136, 0.1);
            }
            50% { 
                box-shadow: 
                    0 0 100px rgba(0, 255, 136, 0.8),
                    0 0 150px rgba(0, 255, 136, 0.5),
                    inset 0 -20px 40px rgba(0, 0, 0, 0.5),
                    inset 0 20px 40px rgba(0, 255, 136, 0.2);
            }
        }
        
        @keyframes pilotEyeScan {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
        }
        
        /* Legacy avatar hide */
        .avatar {
            display: none;
        }
        
        .avatar-3d-container + .avatar {
            display: none;
        }
        
        /* ========== STEP 10.4: CHAT AVATAR PANEL & LIP-SYNC ========== */
        .chat-avatar-panel {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 180px;
            height: 200px;
            background: linear-gradient(135deg, rgba(10, 15, 25, 0.95), rgba(5, 10, 20, 0.98));
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 20px;
            padding: 15px;
            z-index: 999;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 245, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }
        
        .chat-avatar-panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.6), 0 0 40px rgba(0, 245, 255, 0.2);
        }
        
        .chat-avatar-panel.speaking {
            border-color: rgba(128, 0, 255, 0.5);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 40px rgba(128, 0, 255, 0.3);
        }
        
        .chat-avatar-panel.listening {
            border-color: rgba(0, 245, 255, 0.6);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 40px rgba(0, 245, 255, 0.4);
        }
        
        .chat-avatar-mini {
            width: 100px;
            height: 100px;
            position: relative;
        }
        
        .chat-avatar-mini .avatar-3d-head {
            width: 80px;
            height: 80px;
            margin: 0 auto;
        }
        
        .chat-avatar-mini .avatar-3d-eye {
            width: 12px;
            height: 12px;
        }
        
        .chat-avatar-mini .avatar-3d-mouth {
            width: 20px;
            height: 5px;
        }
        
        /* Lip-sync intensity levels */
        .avatar-3d-mouth[data-intensity="1"] { height: 6px; }
        .avatar-3d-mouth[data-intensity="2"] { height: 10px; width: 24px; border-radius: 40%; }
        .avatar-3d-mouth[data-intensity="3"] { height: 14px; width: 22px; border-radius: 50%; }
        .avatar-3d-mouth[data-intensity="4"] { height: 18px; width: 20px; border-radius: 50%; }
        .avatar-3d-mouth[data-intensity="5"] { height: 22px; width: 18px; border-radius: 50%; }
        
        /* Voice wave indicator under avatar */
        .avatar-voice-wave {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 25px;
            margin-top: 10px;
        }
        
        .avatar-voice-wave .wave-bar {
            width: 4px;
            height: 8px;
            background: linear-gradient(180deg, var(--neon-cyan), var(--neon-blue));
            border-radius: 2px;
            transition: height 0.1s ease;
        }
        
        .chat-avatar-panel.speaking .avatar-voice-wave .wave-bar {
            animation: voiceWave 0.3s ease-in-out infinite alternate;
        }
        
        .avatar-voice-wave .wave-bar:nth-child(1) { animation-delay: 0s; }
        .avatar-voice-wave .wave-bar:nth-child(2) { animation-delay: 0.05s; }
        .avatar-voice-wave .wave-bar:nth-child(3) { animation-delay: 0.1s; }
        .avatar-voice-wave .wave-bar:nth-child(4) { animation-delay: 0.15s; }
        .avatar-voice-wave .wave-bar:nth-child(5) { animation-delay: 0.2s; }
        .avatar-voice-wave .wave-bar:nth-child(6) { animation-delay: 0.15s; }
        .avatar-voice-wave .wave-bar:nth-child(7) { animation-delay: 0.1s; }
        
        @keyframes voiceWave {
            0% { height: 5px; }
            100% { height: 20px; }
        }
        
        .avatar-status-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.65em;
            color: var(--neon-cyan);
            letter-spacing: 2px;
            text-align: center;
            margin-top: 8px;
            opacity: 0.8;
        }
        
        .chat-avatar-panel.speaking .avatar-status-text {
            color: var(--neon-purple);
        }
        
        body.pilot-mode-active .chat-avatar-panel {
            border-color: rgba(0, 255, 136, 0.4);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 255, 136, 0.2);
        }
        
        body.pilot-mode-active .avatar-status-text {
            color: #00ff88;
        }
        
        body.pilot-mode-active .avatar-voice-wave .wave-bar {
            background: linear-gradient(180deg, #00ff88, #00cc6a);
        }
        
        /* Voice message in chat */
        .message.voice-msg .message-bubble {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 180px;
        }
        
        .voice-msg-play {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1em;
        }
        
        .voice-msg-play:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .voice-msg-waveform {
            flex: 1;
            height: 28px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .voice-msg-waveform .bar {
            width: 3px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 2px;
        }
        
        .voice-msg-waveform.playing .bar {
            animation: wavePlay 0.5s ease-in-out infinite alternate;
            background: var(--neon-cyan);
        }
        
        @keyframes wavePlay {
            0% { height: 4px; }
            100% { height: 24px; }
        }
        
        .voice-msg-time {
            font-size: 0.75em;
            opacity: 0.7;
            font-family: 'Orbitron', monospace;
        }
        
        /* Emoji reactions on messages */
        .message-reactions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }
        
        .reaction {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .reaction:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        /* Read receipts inline */
        .message.user .message-bubble .message-meta {
            justify-content: flex-end;
        }
        
        /* Reply preview */
        .reply-preview {
            background: rgba(0, 0, 0, 0.2);
            border-left: 3px solid var(--neon-cyan);
            padding: 6px 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 0.85em;
            opacity: 0.8;
        }
        
        .reply-preview .reply-sender {
            font-weight: 600;
            color: var(--neon-cyan);
            margin-bottom: 2px;
        }
        
            border-radius: 50%;
            border: 2px solid var(--neon-cyan);
            animation: avatarRing 2s ease-in-out infinite;
        }
        
        @keyframes avatarFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        
        @keyframes avatarRing {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 0; }
        }
        
        .voice-btn {
            background: linear-gradient(135deg, #ff3366, #ff0066);
            color: #fff;
            position: relative;
        }
        
        .voice-btn:hover {
            box-shadow: 0 10px 30px rgba(255, 51, 102, 0.4), 0 0 20px rgba(255, 51, 102, 0.2);
        }
        
        .voice-btn.listening {
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
            animation: voicePulse 1.5s infinite;
        }
        
        /* Stile per quando il microfono √® in pausa (Gideon sta parlando) */
        .voice-btn.paused {
            background: linear-gradient(135deg, #ff9900, #ff6600);
            animation: voicePaused 1s infinite;
            pointer-events: none;
            opacity: 0.7;
        }
        
        .voice-btn.paused::after {
            content: 'üîá';
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 14px;
        }
        
        @keyframes voicePaused {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 153, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 153, 0, 0.8); }
        }
        
        @keyframes voicePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0, 245, 255, 0.7); }
            50% { box-shadow: 0 0 0 20px rgba(0, 245, 255, 0); }
        }
        
        .tts-toggle {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-magenta));
            color: #fff;
            position: relative;
        }
        
        .tts-toggle:hover {
            box-shadow: 0 10px 30px rgba(128, 0, 255, 0.4);
        }
        
        .tts-toggle.active {
            box-shadow: 0 0 30px rgba(128, 0, 255, 0.6);
        }
        
        .pilot-btn {
            background: linear-gradient(135deg, #ff9900, #ff6600);
            color: #000;
            border: none;
            font-weight: 900;
        }
        
        .pilot-btn:hover {
            box-shadow: 0 10px 30px rgba(255, 153, 0, 0.5), 0 0 40px rgba(255, 153, 0, 0.3);
        }
        
        .pilot-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            animation: pilotActive 2s infinite;
        }
        
        @keyframes pilotActive {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.6); }
            50% { box-shadow: 0 0 50px rgba(0, 255, 136, 0.9); }
        }
        
        .voice-status {
            font-family: 'Orbitron', monospace;
            font-size: 0.75em;
            margin-top: 8px;
            opacity: 0.7;
            letter-spacing: 1px;
        }
        
        /* ========== HANDS-FREE MODE STYLES ========== */
        .hands-free-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.1));
            border: 2px solid var(--neon-green);
            border-radius: 30px;
            padding: 10px 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            animation: handsFreeGlow 2s infinite;
        }
        
        .hands-free-indicator.active {
            display: flex;
        }
        
        .hands-free-dot {
            width: 12px;
            height: 12px;
            background: var(--neon-green);
            border-radius: 50%;
            animation: pulseGreen 1.5s infinite;
        }
        
        .hands-free-indicator.awaiting .hands-free-dot {
            background: var(--neon-cyan);
            animation: pulseCyan 0.8s infinite;
        }
        
        .hands-free-indicator span {
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            color: var(--neon-green);
            letter-spacing: 1px;
        }
        
        @keyframes handsFreeGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.3); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.5); }
        }
        
        @keyframes pulseGreen {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }
        
        @keyframes pulseCyan {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px var(--neon-cyan); }
            50% { opacity: 0.7; box-shadow: 0 0 20px var(--neon-cyan); }
        }
        
        .voice-btn.hands-free {
            background: linear-gradient(135deg, var(--neon-green), #00aa66) !important;
            animation: handsFreeBtn 2s infinite;
        }
        
        @keyframes handsFreeBtn {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.8); }
        }
        
        .hands-free-toggle {
            background: linear-gradient(135deg, #006644, #004433);
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 0.7em;
            transition: all 0.3s;
            margin-left: 10px;
        }
        
        .hands-free-toggle:hover {
            background: linear-gradient(135deg, #008855, #006644);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }
        
        .hands-free-toggle.active {
            background: var(--neon-green);
            color: #000;
        }
        
        /* ========== STEP 10: VANTAGGI HANDS-FREE AVANZATO ========== */
        
        /* Audio Visualizer per hands-free */
        .audio-visualizer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 30px;
            padding: 0 10px;
        }
        
        .audio-bar {
            width: 4px;
            height: 100%;
            background: var(--neon-green);
            border-radius: 2px;
            transform-origin: bottom;
            animation: audioBarIdle 1s ease-in-out infinite;
        }
        
        .audio-visualizer.active .audio-bar {
            animation: audioBarActive 0.3s ease-in-out infinite alternate;
        }
        
        .audio-bar:nth-child(1) { animation-delay: 0s; }
        .audio-bar:nth-child(2) { animation-delay: 0.1s; }
        .audio-bar:nth-child(3) { animation-delay: 0.2s; }
        .audio-bar:nth-child(4) { animation-delay: 0.15s; }
        .audio-bar:nth-child(5) { animation-delay: 0.05s; }
        
        @keyframes audioBarIdle {
            0%, 100% { transform: scaleY(0.3); }
            50% { transform: scaleY(0.5); }
        }
        
        @keyframes audioBarActive {
            0% { transform: scaleY(0.2); }
            100% { transform: scaleY(1); }
        }
        
        /* Conversation State Indicator */
        .conversation-state {
            position: fixed;
            top: 130px;
            right: 20px;
            background: var(--dark-card);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 15px;
            display: none;
            z-index: 999;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }
        
        .conversation-state.active {
            display: block;
        }
        
        .conversation-state-header {
            font-family: 'Orbitron', monospace;
            font-size: 0.7em;
            color: var(--neon-cyan);
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        .conversation-timer {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Orbitron', monospace;
            font-size: 0.9em;
            color: var(--neon-green);
        }
        
        .conversation-timer-icon {
            animation: timerPulse 1s infinite;
        }
        
        @keyframes timerPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .continuous-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), transparent);
            border: 1px solid var(--neon-green);
            border-radius: 20px;
            padding: 4px 12px;
            font-size: 0.7em;
            color: var(--neon-green);
            margin-top: 8px;
        }
        
        .continuous-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--neon-green);
            border-radius: 50%;
            animation: pulseGreen 1s infinite;
        }
        
        /* Vantaggi Panel */
        .advantages-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--dark-card);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 15px;
            display: none;
            z-index: 998;
            max-width: 280px;
            backdrop-filter: blur(10px);
        }
        
        .advantages-panel.show {
            display: block;
            animation: slideInLeft 0.3s ease-out;
        }
        
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .advantages-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .advantages-title {
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            color: var(--neon-cyan);
            letter-spacing: 1px;
        }
        
        .advantages-close {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1.2em;
        }
        
        .advantage-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .advantage-item:last-child {
            border-bottom: none;
        }
        
        .advantage-icon {
            font-size: 1.2em;
            flex-shrink: 0;
        }
        
        .advantage-text {
            font-size: 0.85em;
            color: #aaa;
        }
        
        .advantage-text strong {
            color: var(--neon-green);
        }
        
        /* ========== ACTIVITY LOG PANEL ========== */
        .activity-log-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 380px;
            max-height: 500px;
            background: linear-gradient(135deg, rgba(10, 15, 30, 0.98), rgba(5, 10, 25, 0.98));
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 16px;
            display: none;
            flex-direction: column;
            z-index: 999;
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 245, 255, 0.1);
            overflow: hidden;
        }
        
        .activity-log-panel.visible {
            display: flex;
            animation: slideInLog 0.3s ease-out;
        }
        
        @keyframes slideInLog {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .activity-log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: rgba(0, 245, 255, 0.1);
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
        }
        
        .activity-log-title {
            font-family: 'Orbitron', monospace;
            font-size: 0.85em;
            color: var(--neon-cyan);
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }
        
        .activity-log-controls {
            display: flex;
            gap: 8px;
        }
        
        .activity-log-clear,
        .activity-log-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.1em;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .activity-log-clear:hover,
        .activity-log-close:hover {
            color: var(--neon-cyan);
            background: rgba(0, 245, 255, 0.1);
        }
        
        .activity-log-filters {
            display: flex;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .log-filter {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #888;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .log-filter:hover {
            background: rgba(0, 245, 255, 0.1);
            color: var(--neon-cyan);
        }
        
        .log-filter.active {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }
        
        .activity-log-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            max-height: 350px;
        }
        
        .activity-log-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .activity-log-content::-webkit-scrollbar-thumb {
            background: rgba(0, 245, 255, 0.3);
            border-radius: 3px;
        }
        
        .log-entry {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
            animation: fadeInLog 0.3s ease-out;
        }
        
        @keyframes fadeInLog {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.06);
        }
        
        .log-entry.user {
            border-left-color: var(--neon-purple);
        }
        
        .log-entry.gideon {
            border-left-color: var(--neon-cyan);
        }
        
        .log-entry.system {
            border-left-color: var(--neon-green);
        }
        
        .log-entry.error {
            border-left-color: #ff4444;
        }
        
        .log-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65em;
            color: #666;
            min-width: 60px;
        }
        
        .log-icon {
            font-size: 0.9em;
        }
        
        .log-message {
            flex: 1;
            font-size: 0.78em;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Rajdhani', sans-serif;
            line-height: 1.4;
        }
        
        .activity-log-footer {
            display: flex;
            justify-content: space-between;
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.7em;
            color: #666;
        }
        
        .log-status {
            color: var(--neon-green);
        }
        
        .activity-log-btn {
            position: fixed;
            top: 20px;
            right: 80px;
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2), rgba(139, 92, 246, 0.2));
            border: 2px solid rgba(0, 245, 255, 0.4);
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            z-index: 997;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2);
        }
        
        .activity-log-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.4);
            border-color: var(--neon-cyan);
        }
        
        .activity-log-btn.has-new {
            animation: pulseNew 1s infinite;
        }
        
        @keyframes pulseNew {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 245, 255, 0.2); }
            50% { box-shadow: 0 0 30px rgba(0, 245, 255, 0.6); }
        }
        
        /* ========== STEP 10.5: VOICE COMMANDS PANEL ========== */
        .voice-commands-panel {
            position: fixed;
            bottom: 20px;
            right: 200px;
            background: linear-gradient(135deg, rgba(10, 15, 30, 0.98), rgba(5, 10, 25, 0.98));
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 20px;
            padding: 20px;
            display: none;
            z-index: 998;
            min-width: 320px;
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 245, 255, 0.1);
        }
        
        .voice-commands-panel.show {
            display: block;
            animation: slideInRight 0.3s ease-out;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .voice-commands-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
        }
        
        .voice-commands-title {
            font-family: 'Orbitron', monospace;
            font-size: 0.9em;
            color: var(--neon-cyan);
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }
        
        .voice-commands-close {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1.5em;
            transition: color 0.3s ease;
        }
        
        .voice-commands-close:hover {
            color: var(--neon-cyan);
        }
        
        .voice-commands-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .voice-cmd-category {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
        }
        
        .voice-cmd-category-title {
            font-family: 'Orbitron', monospace;
            font-size: 0.75em;
            color: var(--neon-purple);
            margin-bottom: 8px;
            letter-spacing: 1px;
        }
        
        .voice-cmd-item {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.7);
            padding: 4px 0;
            font-family: 'Rajdhani', sans-serif;
            transition: color 0.3s ease;
        }
        
        .voice-cmd-item:hover {
            color: var(--neon-cyan);
        }
        
        .voice-commands-tip {
            text-align: center;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 245, 255, 0.2);
            font-size: 0.75em;
            color: #00ff88;
            font-family: 'Orbitron', monospace;
            letter-spacing: 1px;
        }
        
        /* Voice Commands Button */
        .voice-cmd-btn {
            position: fixed;
            bottom: 320px;
            right: 25px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-magenta));
            border: 2px solid rgba(128, 0, 255, 0.5);
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            z-index: 997;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 5px 20px rgba(128, 0, 255, 0.4);
            transition: all 0.3s ease;
        }
        
        .voice-cmd-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 30px rgba(128, 0, 255, 0.6);
        }
        
        /* Voice Activity Meter */
        .voice-activity-meter {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
        }
        
        .voice-meter-bar {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .voice-meter-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-cyan));
            border-radius: 2px;
            transition: width 0.1s ease-out;
        }
        
        .voice-meter-label {
            font-size: 0.7em;
            color: #666;
            width: 40px;
            text-align: right;
        }
        
        /* Feedback Sounds Indicator */
        .sound-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 3em;
            z-index: 10000;
            pointer-events: none;
            transition: transform 0.2s ease-out;
        }
        
        .sound-feedback.show {
            transform: translate(-50%, -50%) scale(1);
            animation: feedbackPop 0.5s ease-out;
        }
        
        @keyframes feedbackPop {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        /* Holographic scanning effect */
        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent);
            opacity: 0.3;
            animation: scanLine 4s linear infinite;
            pointer-events: none;
            z-index: 9999;
        }
        
        @keyframes scanLine {
            0% { top: 0; }
            100% { top: 100%; }
        }
        
        /* Gideon AI Identity Panel */
        .gideon-identity {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 10, 30, 0.98));
            border: 1px solid var(--neon-cyan);
            border-radius: 15px;
            padding: 8px 25px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.2);
        }
        
        .gideon-ai-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            animation: aiIconPulse 3s ease-in-out infinite;
        }
        
        @keyframes aiIconPulse {
            0%, 100% { box-shadow: 0 0 10px var(--neon-cyan); }
            50% { box-shadow: 0 0 25px var(--neon-cyan); }
        }
        
        .gideon-name {
            font-family: 'Orbitron', monospace;
            font-size: 1em;
            font-weight: 700;
            background: linear-gradient(90deg, var(--neon-cyan), #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 3px;
        }
        
        .gideon-tagline {
            font-size: 0.65em;
            color: rgba(0, 245, 255, 0.6);
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="scan-line"></div>
    
    <!-- Gideon AI Identity -->
    <div class="gideon-identity">
        <div class="gideon-ai-icon">üß†</div>
        <div>
            <div class="gideon-name">G.I.D.E.O.N.</div>
            <div class="gideon-tagline">Generative Intelligence for Dynamic Executive Operations Network</div>
        </div>
    </div>
    
    <!-- Level Selector Panel -->
    <div class="level-selector-overlay" id="levelSelectorOverlay" onclick="closeLevelSelector()"></div>
    <div class="level-selector" id="levelSelector">
        <div class="level-selector-title">‚öôÔ∏è SELEZIONA LIVELLO OPERATIVO</div>
        
        <div class="level-option normal-opt" onclick="selectLevel('normal')">
            <div class="level-option-icon">üü¢</div>
            <div class="level-option-content">
                <div class="level-option-name">NORMAL</div>
                <div class="level-option-desc">Assistente amichevole per uso quotidiano</div>
                <div class="level-option-features">
                    <span class="level-feature">üí¨ Chat naturale</span>
                    <span class="level-feature">üìä Info sistema</span>
                    <span class="level-feature">üîç Ricerche base</span>
                </div>
            </div>
        </div>
        
        <div class="level-option advanced-opt" onclick="selectLevel('advanced')">
            <div class="level-option-icon">‚ö°</div>
            <div class="level-option-content">
                <div class="level-option-name">ADVANCED</div>
                <div class="level-option-desc">Ragionamento profondo e analisi complesse</div>
                <div class="level-option-features">
                    <span class="level-feature">üß† Reasoning engine</span>
                    <span class="level-feature">üìà Ottimizzazioni</span>
                    <span class="level-feature">üî¨ Analisi dettagliate</span>
                </div>
            </div>
        </div>
        
        <div class="level-option pilot-opt" onclick="selectLevel('pilot')">
            <div class="level-option-icon">üöÄ</div>
            <div class="level-option-content">
                <div class="level-option-name">PILOT</div>
                <div class="level-option-desc">Autonomia completa stile Gideon (The Flash)</div>
                <div class="level-option-features">
                    <span class="level-feature">ü§ñ Esecuzione autonoma</span>
                    <span class="level-feature">‚ö° Azioni proattive</span>
                    <span class="level-feature">üéØ Decisioni automatiche</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Pilot Mode Status Indicator -->
    <div class="pilot-status-indicator" id="pilotStatusIndicator">
        <div class="pilot-dot"></div>
        <span>üöÄ PILOT MODE ACTIVE</span>
    </div>
    
    <!-- Hands-Free Mode Indicator -->
    <div class="hands-free-indicator" id="handsFreeIndicator">
        <div class="hands-free-dot"></div>
        <div class="audio-visualizer" id="audioVisualizer">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
        </div>
        <span id="handsFreeText">üé§ HANDS-FREE ACTIVE</span>
    </div>
    
    <!-- Conversation State Panel -->
    <div class="conversation-state" id="conversationState">
        <div class="conversation-state-header">üí¨ CONVERSAZIONE ATTIVA</div>
        <div class="conversation-timer">
            <span class="conversation-timer-icon">‚è±Ô∏è</span>
            <span id="conversationTime">00:00</span>
        </div>
        <div class="continuous-badge">MODALIT√Ä CONTINUA</div>
        <div class="voice-activity-meter">
            <div class="voice-meter-bar">
                <div class="voice-meter-fill" id="voiceMeterFill"></div>
            </div>
            <span class="voice-meter-label" id="voiceMeterLabel">0%</span>
        </div>
    </div>
    
    <!-- Vantaggi Panel -->
    <div class="advantages-panel" id="advantagesPanel">
        <div class="advantages-header">
            <span class="advantages-title">‚ú® VANTAGGI HANDS-FREE</span>
            <button class="advantages-close" onclick="hideAdvantagesPanel()">√ó</button>
        </div>
        <div class="advantage-item">
            <span class="advantage-icon">üôå</span>
            <span class="advantage-text"><strong>Zero tocchi</strong> - Controlla tutto con la voce</span>
        </div>
        <div class="advantage-item">
            <span class="advantage-icon">‚ö°</span>
            <span class="advantage-text"><strong>Risposta istantanea</strong> - Gideon √® sempre pronto</span>
        </div>
        <div class="advantage-item">
            <span class="advantage-icon">üîÑ</span>
            <span class="advantage-text"><strong>Conversazione fluida</strong> - Nessuna interruzione</span>
        </div>
        <div class="advantage-item">
            <span class="advantage-icon">üéØ</span>
            <span class="advantage-text"><strong>Multi-tasking</strong> - Lavora mentre parli</span>
        </div>
        <div class="advantage-item">
            <span class="advantage-icon">üöÄ</span>
            <span class="advantage-text"><strong>Pilot Mode</strong> - Esecuzione autonoma</span>
        </div>
    </div>
    
    <!-- ========== STEP 10.5: VOICE COMMANDS PANEL ========== -->
    <div class="voice-commands-panel" id="voiceCommandsPanel">
        <div class="voice-commands-header">
            <span class="voice-commands-title">üé§ COMANDI VOCALI</span>
            <button class="voice-commands-close" onclick="hideVoiceCommandsPanel()">√ó</button>
        </div>
        <div class="voice-commands-content">
            <div class="voice-cmd-category">
                <div class="voice-cmd-category-title">üìå LIVELLI</div>
                <div class="voice-cmd-item">"Modalit√† normale"</div>
                <div class="voice-cmd-item">"Modalit√† avanzata"</div>
                <div class="voice-cmd-item">"Modalit√† pilot"</div>
            </div>
            <div class="voice-cmd-category">
                <div class="voice-cmd-category-title">üîä VOCE</div>
                <div class="voice-cmd-item">"Attiva voce"</div>
                <div class="voice-cmd-item">"Silenzio" / "Muto"</div>
                <div class="voice-cmd-item">"Ripeti"</div>
            </div>
            <div class="voice-cmd-category">
                <div class="voice-cmd-category-title">üìä INFO</div>
                <div class="voice-cmd-item">"Chi sei?"</div>
                <div class="voice-cmd-item">"Stato sistema"</div>
                <div class="voice-cmd-item">"Che ore sono?"</div>
            </div>
            <div class="voice-cmd-category">
                <div class="voice-cmd-category-title">‚ö° AZIONI</div>
                <div class="voice-cmd-item">"Pulisci chat"</div>
                <div class="voice-cmd-item">"Stop" / "Ferma"</div>
                <div class="voice-cmd-item">"Aiuto"</div>
            </div>
        </div>
        <div class="voice-commands-tip">üí° Di' "Gideon" + comando</div>
    </div>
    
    <!-- ========== ACTIVITY LOG PANEL ========== -->
    <div class="activity-log-panel" id="activityLogPanel">
        <div class="activity-log-header">
            <span class="activity-log-title">üìã ACTIVITY LOG</span>
            <div class="activity-log-controls">
                <button class="activity-log-clear" onclick="clearActivityLog()" title="Pulisci Log">üóëÔ∏è</button>
                <button class="activity-log-close" onclick="toggleActivityLog()">√ó</button>
            </div>
        </div>
        <div class="activity-log-filters">
            <button class="log-filter active" data-filter="all">Tutti</button>
            <button class="log-filter" data-filter="user">üë§ User</button>
            <button class="log-filter" data-filter="gideon">ü§ñ Gideon</button>
            <button class="log-filter" data-filter="system">‚öôÔ∏è Sistema</button>
        </div>
        <div class="activity-log-content" id="activityLogContent">
            <div class="log-entry system">
                <span class="log-time">--:--:--</span>
                <span class="log-icon">üöÄ</span>
                <span class="log-message">Sessione GIDEON inizializzata</span>
            </div>
        </div>
        <div class="activity-log-footer">
            <span class="log-count" id="logCount">1 evento</span>
            <span class="log-status">üü¢ Live</span>
        </div>
    </div>
    
    <!-- Activity Log Toggle Button -->
    <button class="activity-log-btn" onclick="toggleActivityLog()" title="Activity Log">
        üìã
    </button>
    
    <!-- Voice Commands Button -->
    <button class="voice-cmd-btn" onclick="toggleVoiceCommandsPanel()" title="Comandi Vocali">
        üé§
    </button>
    
    <!-- Sound Feedback Visual -->
    <div class="sound-feedback" id="soundFeedback">üéµ</div>
    
    <!-- ========== STEP 10.4: CHAT MINI AVATAR PANEL ========== -->
    <div class="chat-avatar-panel" id="chatAvatarPanel">
        <div class="chat-avatar-mini">
            <div class="avatar-3d">
                <div class="avatar-3d-head">
                    <div class="avatar-3d-face">
                        <div class="avatar-3d-eyes">
                            <div class="avatar-3d-eye mini-eye" id="miniEyeLeft"></div>
                            <div class="avatar-3d-eye mini-eye" id="miniEyeRight"></div>
                        </div>
                        <div class="avatar-3d-mouth idle" id="miniAvatarMouth" data-intensity="1"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="avatar-voice-wave" id="avatarVoiceWave">
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
        </div>
        <div class="avatar-status-text" id="avatarStatusText">PRONTO</div>
    </div>
    
    <div class="container">
        <header>
            <h1>ü§ñ GIDEON 2.0</h1>
            <p class="subtitle">ADVANCED AI INTERFACE</p>
            <div class="header-status-row">
                <div class="status" id="connectionStatus">
                    <span id="statusText">INITIALIZING...</span>
                </div>
                <!-- Security Badge -->
                <div class="security-badge" id="securityBadge" onclick="showSecurityDetails()" title="Stato sicurezza sessione">
                    <span class="security-icon">üîí</span>
                    <span class="security-text" id="securityText">SECURE</span>
                </div>
                <div class="level-indicator normal" id="levelIndicator" onclick="openLevelSelector()" title="Clicca per cambiare livello">
                    <span class="level-icon">üü¢</span>
                    <div>
                        <span class="level-text" id="levelText">NORMAL</span>
                        <span class="level-desc" id="levelDesc">Assistente</span>
                    </div>
                    <span class="personality-trait" id="personalityTrait">Amichevole</span>
                </div>
            </div>
        </header>

        <div class="grid">
            <div class="card">
                <!-- Avatar 3D - Hologram Style (The Flash Gideon) -->
                <div class="avatar-3d-container" id="avatar3D">
                    <div class="avatar-3d">
                        <div class="avatar-3d-ring"></div>
                        <div class="avatar-3d-head">
                            <div class="avatar-3d-circuits"></div>
                            <div class="avatar-3d-face">
                                <div class="avatar-3d-eyes">
                                    <div class="avatar-3d-eye" id="eyeLeft"></div>
                                    <div class="avatar-3d-eye" id="eyeRight"></div>
                                </div>
                                <div class="avatar-3d-mouth idle" id="avatarMouth"></div>
                            </div>
                            <!-- Hologram effects -->
                            <div class="hologram-scanlines"></div>
                            <div class="hologram-glitch"></div>
                            <div class="hologram-particles"></div>
                        </div>
                    </div>
                </div>
                <!-- Avatar State Indicator -->
                <div class="avatar-state-indicator" id="avatarStateIndicator">
                    <span class="state-dot"></span>
                    <span class="state-text" id="avatarStateText">IDLE</span>
                </div>
                <h2>‚ö° SISTEMA</h2>
                <div class="metric">
                    <div class="metric-label">CPU CORE</div>
                    <div class="metric-value" id="cpu">--</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="cpuBar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">NEURAL RAM</div>
                    <div class="metric-value" id="memory">--</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="memoryBar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">STORAGE MATRIX</div>
                    <div class="metric-value" id="disk">--</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="diskBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìä ANALYTICS</h2>
                <div class="metric">
                    <div class="metric-label">PERFORMANCE INDEX</div>
                    <div class="metric-value" id="efficiency">--</div>
                </div>
                <div class="metric">
                    <div class="metric-label">COMMANDS PROCESSED</div>
                    <div class="metric-value" id="commands">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">ACTIVE MEMORY NODES</div>
                    <div class="metric-value" id="memoryCount">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">OPERATION MODE</div>
                    <div class="metric-value" id="mode" style="font-size: 1.2em;">STANDARD</div>
                </div>
            </div>
            
            <!-- Actions Panel -->
            <div class="card actions-card">
                <h2>‚ö° AZIONI & ROUTINE</h2>
                
                <div class="actions-tabs">
                    <button class="action-tab active" onclick="showActionTab('quick')">QUICK</button>
                    <button class="action-tab" onclick="showActionTab('routines')">ROUTINE</button>
                    <button class="action-tab" onclick="showActionTab('logs')">LOG</button>
                </div>
                
                <!-- Quick Actions -->
                <div id="quickActionsPanel" class="action-panel active">
                    <div class="action-grid">
                        <button class="action-btn safe" onclick="executeAction('system_status')">
                            <span class="action-icon">üìä</span>
                            <span class="action-label">System Status</span>
                        </button>
                        <button class="action-btn safe" onclick="executeAction('memory_report')">
                            <span class="action-icon">üß†</span>
                            <span class="action-label">Memory Report</span>
                        </button>
                        <button class="action-btn safe" onclick="executeAction('disk_usage')">
                            <span class="action-icon">üíæ</span>
                            <span class="action-label">Disk Usage</span>
                        </button>
                        <button class="action-btn elevated" onclick="executeAction('optimize_memory')">
                            <span class="action-icon">‚ö°</span>
                            <span class="action-label">Optimize RAM</span>
                            <span class="action-level">ELEVATED</span>
                        </button>
                        <button class="action-btn critical" onclick="executeAction('backup_create')">
                            <span class="action-icon">üíø</span>
                            <span class="action-label">Create Backup</span>
                            <span class="action-level">PILOT</span>
                        </button>
                        <button class="action-btn destructive" onclick="executeAction('system_cleanup')">
                            <span class="action-icon">üßπ</span>
                            <span class="action-label">System Cleanup</span>
                            <span class="action-level">CRITICAL</span>
                        </button>
                    </div>
                </div>
                
                <!-- Routines Panel -->
                <div id="routinesPanel" class="action-panel">
                    <div id="routinesList" class="routines-list">
                        <div class="loading-routines">Loading routines...</div>
                    </div>
                    <button class="refresh-btn" onclick="loadRoutines()">üîÑ Refresh</button>
                </div>
                
                <!-- Action Logs Panel -->
                <div id="logsPanel" class="action-panel">
                    <div id="actionLogsList" class="action-logs-list">
                        <div class="loading-logs">Loading logs...</div>
                    </div>
                    <div class="logs-actions">
                        <button class="refresh-btn" onclick="loadActionLogs()">üîÑ Refresh</button>
                        <button class="rollback-btn" onclick="rollbackLastAction()" id="rollbackBtn" disabled>‚Ü©Ô∏è Rollback</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="chat-container">
            <h2>üí¨ NEURAL INTERFACE</h2>
            
            <div class="quick-actions">
                <button class="quick-btn" onclick="sendQuickMessage('Che ora √®?')">üïê TIME</button>
                <button class="quick-btn" onclick="sendQuickMessage('Qual √® lo stato del sistema?')">üìä STATUS</button>
                <button class="quick-btn" onclick="sendQuickMessage('Calcola efficienza')">üßÆ CALC</button>
                <button class="quick-btn" onclick="sendQuickMessage('Analizza il sistema')">üîç SCAN</button>
                <button class="quick-btn" onclick="sendQuickMessage('Suggerimenti di ottimizzazione')">‚ö° OPTIMIZE</button>
                <button class="quick-btn" onclick="sendQuickMessage('Ragiona sul sistema')">üß† REASON</button>
                <button id="advancedBtn" class="quick-btn" onclick="toggleAdvancedMode()" style="background: linear-gradient(135deg, rgba(128,0,255,0.4), rgba(0,128,255,0.4)); border: 1px solid var(--neon-purple);">‚ö° ADVANCED</button>
                <button id="pilotBtn" class="quick-btn pilot-btn" onclick="togglePilotMode()">üöÄ PILOT MODE</button>
                <button class="quick-btn" onclick="exportLog()" style="background: rgba(100,100,100,0.4);">üìã LOG</button>
            </div>

            <div class="messages" id="messages">
                <div class="message gideon">
                    <div class="message-content">
                        <div class="message-avatar">G</div>
                        <div class="message-text">
                            <strong>GIDEON 2.0 NEURAL INTERFACE ONLINE</strong><br>
                            Live chat system active. All responses are generated upon complete reasoning analysis.<br>
                            <small>üé§ Voice control available | ‚ö° Real-time processing</small>
                            <div class="message-time">SYSTEM INITIALIZED</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Typing indicator - WhatsApp style "Gideon sta scrivendo..." -->
            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-avatar-mini">
                    <span class="typing-avatar-letter">G</span>
                    <div class="typing-avatar-pulse"></div>
                </div>
                <div class="typing-content">
                    <div class="typing-name">Gideon</div>
                    <div class="typing-status">
                        <span class="typing-text" id="typingText">sta scrivendo</span>
                        <div class="typing-dots">
                            <span></span><span></span><span></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="input-container">
                <button id="voiceBtn" class="voice-btn" onclick="toggleVoice()">üé§ VOICE</button>
                <button id="ttsBtn" class="tts-toggle active" onclick="toggleTTS()">üîä SPEAK</button>
                <button id="handsFreeBtn" class="hands-free-toggle" onclick="toggleHandsFree()">üôå HANDS-FREE</button>
                <input type="text" id="messageInput" placeholder="Enter command or message..." />
                <button id="sendBtn" onclick="sendMessage()">üì§ SEND</button>
            </div>
            <div class="voice-status" id="voiceStatus"></div>
        </div>
    </div>

    <script>
        const API_URL = 'http://127.0.0.1:8001';
        const GIDEON_API = `${API_URL}/api/gideon`;  // Nuova API GIDEON 3.0
        const JARVIS_API = `${API_URL}/api/jarvis`;  // Nuova API JARVIS
        const SYSTEM_API = `${API_URL}/api/system`;  // Nuova API System
        let ws = null;
        let commandCount = 0;
        
        // GIDEON 3.0 Mode
        let currentMode = 'copilot';  // passive, copilot, pilot, executive
        let responseLevel = 'normal';  // normal, advanced
        
        // Voice Recognition
        let recognition = null;
        let isListening = false;
        let continuousMode = false;
        
        // ========== STEP 9: HANDS-FREE MODE ==========
        let handsFreeMode = false;
        let awaitingCommand = false;
        let lastSpeechTime = 0;
        let silenceTimer = null;
        const WAKE_WORDS = ['gideon', 'ehi gideon', 'hey gideon', 'ok gideon', 'ciao gideon'];
        const SLEEP_PHRASES = ['gideon riposa', 'gideon dormi', 'stop ascolto', 'basta ascoltare', 'smetti di ascoltare', 'hands free off', 'disattiva hands free'];
        const SILENCE_TIMEOUT = 2000; // ms di silenzio prima di considerare comando finito
        
        // ========== STEP 10: ENHANCED HANDS-FREE ==========
        let conversationActive = false;
        let conversationStartTime = null;
        let conversationTimer = null;
        let continuousConversationTimeout = null;
        const CONTINUOUS_CONVERSATION_DELAY = 8000; // 8 secondi per continuare senza wake word
        let voiceActivityLevel = 0;
        
        // Audio Feedback
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Text-to-Speech
        let ttsEnabled = true;
        
        // Pilot Mode - Hands-Free Advanced
        let pilotModeActive = false;
        const PILOT_VOICE_PHRASES = [
            'assistente modalit√† pilota',
            'assistente modalita pilota',
            'gideon modalit√† pilota',
            'gideon modalita pilota',
            'attiva modalit√† pilota',
            'attiva modalita pilota',
            'pilot mode'
        ];
        const PILOT_DEACTIVATE_PHRASES = [
            'disattiva pilota',
            'disattiva modalit√† pilota',
            'disattiva modalita pilota',
            'gideon disattiva pilota',
            'gideon disattiva modalit√† pilota',
            'gideon disattiva modalita pilota',
            'esci da pilota',
            'esci dalla modalit√† pilota',
            'termina pilota',
            'termina modalit√† pilota',
            'modalit√† normale',
            'modalita normale',
            'exit pilot',
            'stop pilot',
            'basta pilota',
            'stop',
            'fermati',
            'gideon stop',
            'gideon fermati',
            'gideon basta'
        ];
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let voicesList = [];
        
        // Pilot Mode command queue
        let pilotCommandQueue = [];
        let pilotExecuting = false;
        
        // Current operation level
        let currentLevel = 'normal'; // normal, advanced, pilot
        
        // Session start time for metrics
        window.sessionStartTime = Date.now();
        
        // Level definitions - Gideon The Flash style
        const GIDEON_LEVELS = {
            normal: {
                name: 'NORMAL',
                icon: 'üü¢',
                desc: 'Assistente',
                personality: 'Amichevole',
                color: 'var(--neon-cyan)',
                capabilities: ['chat', 'info', 'search'],
                autonomy: 0.2,
                greeting: 'Ciao! Come posso aiutarti?'
            },
            advanced: {
                name: 'ADVANCED',
                icon: '‚ö°',
                desc: 'Analista',
                personality: 'Analitico',
                color: 'var(--neon-purple)',
                capabilities: ['chat', 'info', 'search', 'reasoning', 'optimization', 'analysis'],
                autonomy: 0.5,
                greeting: 'Modalit√† avanzata attivata. Pronto per analisi complesse.'
            },
            pilot: {
                name: 'PILOT',
                icon: 'üöÄ',
                desc: 'Autonomo',
                personality: 'Proattivo',
                color: '#00ff88',
                capabilities: ['chat', 'info', 'search', 'reasoning', 'optimization', 'analysis', 'execute', 'proactive', 'decisions'],
                autonomy: 1.0,
                greeting: 'Modalit√† Pilot attivata. Sono Gideon, la tua intelligenza artificiale autonoma. Eseguir√≤ le azioni necessarie senza chiedere conferma.'
            }
        };
        
        // Conversation log for traceability
        let conversationLog = [];
        
        // Gideon autonomous behavior tracking
        let gideonAutonomyActive = false;
        let proactiveActionsQueue = [];
        
        // ========== LEVEL SELECTOR FUNCTIONS ==========
        
        function openLevelSelector() {
            document.getElementById('levelSelectorOverlay').classList.add('show');
            document.getElementById('levelSelector').classList.add('show');
            
            // Mark current level as selected
            document.querySelectorAll('.level-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`.level-option.${currentLevel}-opt`)?.classList.add('selected');
        }
        
        function closeLevelSelector() {
            document.getElementById('levelSelectorOverlay').classList.remove('show');
            document.getElementById('levelSelector').classList.remove('show');
        }
        
        function selectLevel(level) {
            closeLevelSelector();
            setLevel(level);
            
            // Play feedback sound
            playFeedbackSound('success');
            
            // Log to Activity Log
            const levelInfo = GIDEON_LEVELS[level];
            addLogEntry('system', `Livello cambiato: ${levelInfo.name}`, levelInfo.icon);
            
            // Announce level change
            speak(levelInfo.greeting);
            
            // Show confirmation message
            addMessage(`üîÑ Livello operativo: <strong>${levelInfo.name}</strong> - ${levelInfo.desc}`, 'gideon');
            
            // Send to backend
            fetch(`${API_URL}/api/pilot/level`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ level: level })
            }).catch(err => console.error('Error setting level:', err));
            
            // Special handling for Pilot mode
            if (level === 'pilot') {
                activatePilotMode('ui');
            } else if (pilotModeActive) {
                deactivatePilotMode('ui');
            }
        }
        
        // Update level indicator with Gideon-style info
        function setLevel(level) {
            currentLevel = level;
            const indicator = document.getElementById('levelIndicator');
            const levelText = document.getElementById('levelText');
            const levelDesc = document.getElementById('levelDesc');
            const modeDisplay = document.getElementById('mode');
            const personalityTrait = document.getElementById('personalityTrait');
            
            const levelInfo = GIDEON_LEVELS[level] || GIDEON_LEVELS.normal;
            
            // Remove all level classes
            indicator.classList.remove('normal', 'advanced', 'pilot');
            indicator.classList.add(level);
            
            // Update UI elements
            levelText.textContent = levelInfo.name;
            if (levelDesc) levelDesc.textContent = levelInfo.desc;
            document.querySelector('#levelIndicator .level-icon').textContent = levelInfo.icon;
            if (modeDisplay) modeDisplay.textContent = levelInfo.name;
            if (personalityTrait) personalityTrait.textContent = levelInfo.personality;
            
            // Update Gideon autonomy
            gideonAutonomyActive = level === 'pilot';
            
            logEvent('LEVEL_CHANGE', { level: level, autonomy: levelInfo.autonomy });
        }
        
        // Log event for traceability
        function logEvent(type, data) {
            const logEntry = {
                timestamp: new Date().toISOString(),
                type: type,
                level: currentLevel,
                data: data
            };
            
            conversationLog.push(logEntry);
            console.log(`üìã [${logEntry.timestamp}] [${type}] [${currentLevel.toUpperCase()}]`, data);
            
            // Keep only last 1000 entries
            if (conversationLog.length > 1000) {
                conversationLog = conversationLog.slice(-1000);
            }
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('gideon_log', JSON.stringify(conversationLog.slice(-100)));
            } catch (e) {
                // Storage full, clear old entries
                conversationLog = conversationLog.slice(-50);
            }
        }
        
        // Log message (user or gideon)
        function logMessage(sender, message, metadata = {}) {
            logEvent('MESSAGE', {
                sender: sender,
                message: message.substring(0, 500), // Truncate long messages
                ...metadata
            });
        }
        
        // Get conversation log
        function getConversationLog() {
            return conversationLog;
        }
        
        // Export log to console
        function exportLog() {
            console.log('üìã === GIDEON CONVERSATION LOG ===');
            console.table(conversationLog);
            return conversationLog;
        }

        // ========== ACTIONS MANAGEMENT ==========
        let currentActionTab = 'quick';
        
        function showActionTab(tab) {
            currentActionTab = tab;
            
            // Update tabs
            document.querySelectorAll('.action-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.action-tab:nth-child(${tab === 'quick' ? 1 : tab === 'routines' ? 2 : 3})`).classList.add('active');
            
            // Update panels
            document.querySelectorAll('.action-panel').forEach(p => p.classList.remove('active'));
            document.getElementById(tab === 'quick' ? 'quickActionsPanel' : tab === 'routines' ? 'routinesPanel' : 'logsPanel').classList.add('active');
            
            // Load data if needed
            if (tab === 'routines') loadRoutines();
            if (tab === 'logs') loadActionLogs();
        }
        
        async function executeAction(actionType, params = {}) {
            try {
                const isPilot = pilotModeActive;
                
                addMessage(`Esegui azione: ${actionType}`, 'user');
                showTypingIndicator('EXECUTING...');
                
                const response = await fetch(`${API_URL}/api/actions/execute`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action_type: actionType,
                        params: params,
                        force: false,
                        pilot_confirmed: isPilot
                    })
                });
                
                const result = await response.json();
                hideTypingIndicator();
                
                if (result.success) {
                    const resultText = formatActionResult(actionType, result.result);
                    addMessage(`‚úÖ Azione completata: ${actionType}\n\n${resultText}`, 'gideon');
                    
                    if (result.can_rollback) {
                        document.getElementById('rollbackBtn').disabled = false;
                    }
                    
                    // Speak result summary
                    if (ttsEnabled) {
                        speak(`Azione ${actionType.replace('_', ' ')} completata con successo.`);
                    }
                } else {
                    let errorMsg = result.error || 'Errore sconosciuto';
                    
                    if (result.requires === 'pilot_mode') {
                        errorMsg = 'üö´ Questa azione richiede Pilot Mode attivo.\nAttiva Pilot Mode con il comando vocale per procedere.';
                    } else if (result.requires === 'confirmation') {
                        errorMsg = '‚ö†Ô∏è Azione elevata richiede conferma.\nRipeti il comando per confermare.';
                    } else if (result.requires === 'pilot_confirmation') {
                        errorMsg = 'üîê Azione critica richiede conferma esplicita in Pilot Mode.';
                    }
                    
                    addMessage(`‚ùå ${errorMsg}`, 'gideon');
                    
                    if (ttsEnabled) {
                        speak(errorMsg.replace(/[üö´‚ö†Ô∏èüîê]/g, ''));
                    }
                }
                
                // Refresh logs
                if (currentActionTab === 'logs') loadActionLogs();
                
            } catch (error) {
                hideTypingIndicator();
                addMessage(`‚ùå Errore esecuzione azione: ${error.message}`, 'gideon');
            }
        }
        
        function formatActionResult(actionType, result) {
            if (!result) return 'Nessun risultato';
            
            switch(actionType) {
                case 'system_status':
                    return `üìä CPU: ${result.cpu?.percent}%\nüß† RAM: ${result.memory?.percent}% (${result.memory?.used_gb}GB/${result.memory?.total_gb}GB)\nüíæ Disco: ${result.disk?.percent}%\nüî¢ Processi: ${result.processes}`;
                    
                case 'memory_report':
                    let report = `üß† RAM: ${result.memory?.percent}% utilizzata\nüìä Disponibile: ${result.memory?.available_gb}GB`;
                    if (result.top_consumers?.length > 0) {
                        report += '\n\nüîù Top consumers:';
                        result.top_consumers.slice(0, 5).forEach(p => {
                            report += `\n  ‚Ä¢ ${p.name}: ${p.memory_percent?.toFixed(1)}%`;
                        });
                    }
                    return report;
                    
                case 'disk_usage':
                    let diskInfo = 'üíæ Partizioni:';
                    result.partitions?.forEach(p => {
                        diskInfo += `\n  ${p.mountpoint}: ${p.used_gb}GB/${p.total_gb}GB (${p.percent}%)`;
                    });
                    return diskInfo;
                    
                case 'optimize_memory':
                    return `‚ö° Garbage collection eseguito\nüìà Memoria liberata: ${result.memory_freed_mb}MB\n‚úÖ Disponibile: ${result.current_available_gb}GB`;
                    
                case 'backup_create':
                    return `üíø Backup creato: ${result.backup_name}\nüìÅ Sorgente: ${result.source}\nüìù ${result.note || ''}`;
                    
                default:
                    return JSON.stringify(result, null, 2);
            }
        }
        
        async function loadRoutines() {
            const container = document.getElementById('routinesList');
            container.innerHTML = '<div class="loading-routines">Loading...</div>';
            
            try {
                const response = await fetch(`${API_URL}/api/actions/routines`);
                const data = await response.json();
                
                if (data.routines?.length > 0) {
                    container.innerHTML = data.routines.map(r => `
                        <div class="routine-item">
                            <div class="routine-info">
                                <div class="routine-name">${r.name}</div>
                                <div class="routine-schedule">${r.schedule} | Runs: ${r.run_count} | ${r.last_result || 'never'}</div>
                            </div>
                            <div class="routine-toggle ${r.enabled ? 'enabled' : ''}" 
                                 onclick="toggleRoutine('${r.name}', ${!r.enabled})"
                                 data-level="${r.level}"></div>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<div class="loading-routines">No routines configured</div>';
                }
            } catch (error) {
                container.innerHTML = `<div class="loading-routines">Error: ${error.message}</div>`;
            }
        }
        
        async function toggleRoutine(routineId, enabled) {
            try {
                const response = await fetch(`${API_URL}/api/actions/routines/toggle`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ routine_id: routineId, enabled: enabled })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    loadRoutines();
                    addMessage(`‚úÖ Routine "${routineId}" ${enabled ? 'attivata' : 'disattivata'}`, 'gideon');
                } else {
                    addMessage(`‚ùå Impossibile modificare routine: ${result.detail || 'Richiede Pilot Mode'}`, 'gideon');
                }
            } catch (error) {
                addMessage(`‚ùå Errore: ${error.message}`, 'gideon');
            }
        }
        
        async function loadActionLogs() {
            const container = document.getElementById('actionLogsList');
            container.innerHTML = '<div class="loading-logs">Loading...</div>';
            
            try {
                const response = await fetch(`${API_URL}/api/actions/logs?limit=20`);
                const data = await response.json();
                
                if (data.logs?.length > 0) {
                    container.innerHTML = data.logs.map(log => `
                        <div class="action-log-item ${log.status}">
                            <span class="log-time">${log.started_at ? new Date(log.started_at).toLocaleTimeString() : '--'}</span>
                            <span class="log-action">${log.action_type}</span>
                            <span class="log-status ${log.status}">${log.status.toUpperCase()}</span>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<div class="loading-logs">No action logs yet</div>';
                }
                
                // Check rollback availability
                const rollbackResponse = await fetch(`${API_URL}/api/actions/rollback`);
                const rollbackData = await rollbackResponse.json();
                document.getElementById('rollbackBtn').disabled = !rollbackData.rollback_stack?.length;
                
            } catch (error) {
                container.innerHTML = `<div class="loading-logs">Error: ${error.message}</div>`;
            }
        }
        
        async function rollbackLastAction() {
            if (!pilotModeActive) {
                addMessage('üö´ Rollback richiede Pilot Mode attivo', 'gideon');
                return;
            }
            
            try {
                showTypingIndicator('ROLLING BACK...');
                
                const response = await fetch(`${API_URL}/api/actions/rollback`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                hideTypingIndicator();
                
                if (result.success) {
                    addMessage(`‚Ü©Ô∏è Rollback completato per azione: ${result.action_id}`, 'gideon');
                    loadActionLogs();
                } else {
                    addMessage(`‚ùå Rollback fallito: ${result.error}`, 'gideon');
                }
            } catch (error) {
                hideTypingIndicator();
                addMessage(`‚ùå Errore rollback: ${error.message}`, 'gideon');
            }
        }

        // Inizializza Text-to-Speech
        function initTTS() {
            if ('speechSynthesis' in window) {
                // Carica voci disponibili
                function loadVoices() {
                    voicesList = speechSynthesis.getVoices();
                    console.log('üîä Voci TTS disponibili:', voicesList.length);
                }
                
                loadVoices();
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = loadVoices;
                }
                
                console.log('‚úÖ TTS inizializzato');
                return true;
            } else {
                console.warn('‚ö†Ô∏è TTS non supportato dal browser');
                document.getElementById('ttsBtn').disabled = true;
                return false;
            }
        }
        
        function toggleTTS() {
            ttsEnabled = !ttsEnabled;
            const ttsBtn = document.getElementById('ttsBtn');
            
            if (ttsEnabled) {
                ttsBtn.classList.add('active');
                ttsBtn.textContent = 'üîä Parlato';
                console.log('üîä TTS attivato');
                // Usa setTimeout per evitare che speak() sia chiamato prima che ttsEnabled sia true
                setTimeout(() => speak('TTS attivo. Gideon ora parler√† le risposte.'), 100);
            } else {
                ttsBtn.classList.remove('active');
                ttsBtn.textContent = 'üîá Muto';
                // Ferma qualsiasi speech in corso
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                console.log('üîá TTS disattivato');
            }
        }
        
        function speak(text) {
            if (!ttsEnabled || !text) return;
            
            // Pulisci il testo da HTML tags
            const cleanText = text.replace(/<[^>]*>/g, '').replace(/\n+/g, '. ');
            
            // Log to Activity Log
            addLogEntry('tts', `TTS: "${cleanText.substring(0, 40)}${cleanText.length > 40 ? '...' : ''}"`, 'üîä');
            
            // Ferma qualsiasi speech precedente
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            // ========== ANTI-ECHO: Pausa riconoscimento vocale mentre Gideon parla ==========
            const wasListening = isListening;
            const wasContinuousMode = continuousMode;
            if (isListening && recognition) {
                console.log('üîá Pausa microfono (anti-echo)');
                recognition.stop();
                isListening = false;
                // Non resettare continuousMode, lo useremo per riprendere
            }
            
            // Crea utterance
            currentUtterance = new SpeechSynthesisUtterance(cleanText);
            
            // Configura voce italiana se disponibile
            const italianVoice = voicesList.find(voice => 
                voice.lang.startsWith('it') || voice.name.toLowerCase().includes('italian')
            );
            
            if (italianVoice) {
                currentUtterance.voice = italianVoice;
                currentUtterance.lang = 'it-IT';
            } else {
                currentUtterance.lang = 'it-IT';
            }
            
            // Configura parametri voce
            currentUtterance.rate = 1.0;      // Velocit√† normale
            currentUtterance.pitch = 1.0;     // Tono normale
            currentUtterance.volume = 1.0;    // Volume massimo
            
            // Eventi
            currentUtterance.onstart = () => {
                console.log('üó£Ô∏è Gideon sta parlando...');
                document.getElementById('voiceStatus').textContent = 'üó£Ô∏è Gideon sta parlando...';
                // Attiva lip sync Avatar 3D
                setAvatarState('speaking');
                
                // Aggiorna UI per mostrare che il mic √® in pausa
                document.getElementById('voiceBtn').classList.remove('listening');
                document.getElementById('voiceBtn').classList.add('paused');
            };
            
            currentUtterance.onend = () => {
                console.log('‚úÖ Speech completato');
                // Torna a idle
                setAvatarState('idle');
                
                // Rimuovi classe paused
                document.getElementById('voiceBtn').classList.remove('paused');
                
                // ========== ANTI-ECHO: Riprendi ascolto dopo delay ==========
                // Aspetta 300ms per evitare che il microfono catturi l'eco residuo
                setTimeout(() => {
                    // ========== HANDS-FREE: Auto-resume listening after TTS ==========
                    if (handsFreeMode) {
                        // In hands-free, torna in attesa wake word
                        awaitingCommand = false;
                        updateHandsFreeIndicator('idle');
                        document.getElementById('voiceStatus').textContent = 'üôå HANDS-FREE: Di\' "Gideon" per continuare';
                        
                        // Riprendi ascolto
                        if (!isListening) {
                            continuousMode = true;
                            startVoiceRecognition();
                            console.log('üé§ Microfono riattivato (hands-free)');
                        }
                    } else if (wasContinuousMode || wasListening) {
                        // Riprendi ascolto se era attivo prima
                        continuousMode = wasContinuousMode;
                        if (!isListening) {
                            startVoiceRecognition();
                            console.log('üé§ Microfono riattivato (continuous)');
                        }
                        document.getElementById('voiceStatus').textContent = 'üé§ Gideon in ascolto - Parla pure!';
                    } else {
                        document.getElementById('voiceStatus').textContent = '';
                    }
                }, 300); // 300ms delay anti-echo
            };
            
            currentUtterance.onerror = (event) => {
                console.error('‚ùå Errore TTS:', event.error);
                setAvatarState('idle');
                document.getElementById('voiceBtn').classList.remove('paused');
                
                // Riprendi ascolto anche in caso di errore
                if (wasListening || handsFreeMode) {
                    setTimeout(() => {
                        if (!isListening) {
                            continuousMode = wasContinuousMode || handsFreeMode;
                            startVoiceRecognition();
                        }
                    }, 300);
                }
            };
            
            // Parla!
            speechSynthesis.speak(currentUtterance);
        }
        
        // ========== AVATAR 3D CONTROL ==========
        let avatarState = 'idle'; // idle, listening, speaking, thinking
        let blinkInterval = null;
        let lipSyncInterval = null;
        let lipSyncAnalyser = null;
        
        // ========== STEP 10.4: ENHANCED LIP-SYNC & AVATAR SYNC ==========
        function initAvatar3D() {
            // Start random blinking
            startBlinking();
            setAvatarState('idle');
            
            // Initialize mini avatar in chat panel
            updateChatAvatarPanel('idle');
            
            console.log('ü§ñ Avatar 3D initialized with lip-sync');
        }
        
        // Sync mini avatar panel with main avatar state
        function updateChatAvatarPanel(state) {
            const panel = document.getElementById('chatAvatarPanel');
            const statusText = document.getElementById('avatarStatusText');
            const miniMouth = document.getElementById('miniAvatarMouth');
            
            if (!panel) return;
            
            panel.classList.remove('speaking', 'listening', 'thinking');
            
            const stateLabels = {
                'idle': 'PRONTO',
                'listening': 'üëÇ ASCOLTO...',
                'speaking': 'üó£Ô∏è PARLO...',
                'thinking': 'üß† ANALIZZO...'
            };
            
            switch(state) {
                case 'speaking':
                    panel.classList.add('speaking');
                    if (miniMouth) {
                        miniMouth.classList.remove('idle');
                        miniMouth.classList.add('speaking');
                    }
                    startMiniLipSync();
                    break;
                case 'listening':
                    panel.classList.add('listening');
                    if (miniMouth) {
                        miniMouth.classList.remove('speaking');
                        miniMouth.classList.add('idle');
                    }
                    stopMiniLipSync();
                    break;
                case 'thinking':
                    panel.classList.add('thinking');
                    stopMiniLipSync();
                    break;
                default:
                    stopMiniLipSync();
                    if (miniMouth) {
                        miniMouth.classList.remove('speaking');
                        miniMouth.classList.add('idle');
                    }
            }
            
            if (statusText) {
                statusText.textContent = stateLabels[state] || 'PRONTO';
            }
        }
        
        // Advanced lip-sync animation based on speech
        function startMiniLipSync() {
            const miniMouth = document.getElementById('miniAvatarMouth');
            const waveBars = document.querySelectorAll('#avatarVoiceWave .wave-bar');
            
            if (!miniMouth) return;
            
            // Simulate voice intensity changes
            let intensity = 1;
            lipSyncInterval = setInterval(() => {
                // Random mouth opening intensity (1-5)
                intensity = Math.floor(Math.random() * 5) + 1;
                miniMouth.setAttribute('data-intensity', intensity);
                
                // Animate wave bars
                waveBars.forEach((bar, i) => {
                    const height = 5 + Math.random() * 15 + (intensity * 2);
                    bar.style.height = `${height}px`;
                });
            }, 100);
        }
        
        function stopMiniLipSync() {
            if (lipSyncInterval) {
                clearInterval(lipSyncInterval);
                lipSyncInterval = null;
            }
            
            const miniMouth = document.getElementById('miniAvatarMouth');
            const waveBars = document.querySelectorAll('#avatarVoiceWave .wave-bar');
            
            if (miniMouth) {
                miniMouth.setAttribute('data-intensity', '1');
            }
            
            waveBars.forEach(bar => {
                bar.style.height = '8px';
            });
        }
        
        // Real lip-sync with audio analyser (if supported)
        function initRealLipSync() {
            try {
                if (!audioContext) return;
                
                lipSyncAnalyser = audioContext.createAnalyser();
                lipSyncAnalyser.fftSize = 32;
                lipSyncAnalyser.smoothingTimeConstant = 0.5;
                
                console.log('üé§ Real lip-sync initialized');
            } catch (e) {
                console.warn('Lip-sync analyser not available:', e);
            }
        }
        
        // Get audio level from speech (0-1)
        function getAudioLevel() {
            if (!lipSyncAnalyser) return Math.random();
            
            const dataArray = new Uint8Array(lipSyncAnalyser.frequencyBinCount);
            lipSyncAnalyser.getByteFrequencyData(dataArray);
            
            // Calculate average amplitude
            const sum = dataArray.reduce((a, b) => a + b, 0);
            return sum / (dataArray.length * 255);
        }
        
        // Enhanced avatar expression based on message content
        function setAvatarExpression(text) {
            const container = document.getElementById('avatar3D');
            const panel = document.getElementById('chatAvatarPanel');
            
            if (!container) return;
            
            // Remove previous expressions
            container.classList.remove('happy', 'concerned', 'excited', 'thinking-deep');
            if (panel) panel.classList.remove('happy', 'concerned', 'excited');
            
            // Analyze text sentiment for expression
            const lowerText = text.toLowerCase();
            
            if (lowerText.includes('ottimo') || lowerText.includes('perfetto') || 
                lowerText.includes('eccellente') || lowerText.includes('fantastico') ||
                lowerText.includes('üéâ') || lowerText.includes('‚úÖ')) {
                container.classList.add('happy');
                if (panel) panel.classList.add('happy');
            } else if (lowerText.includes('errore') || lowerText.includes('problema') ||
                       lowerText.includes('attenzione') || lowerText.includes('‚ö†Ô∏è') ||
                       lowerText.includes('‚ùå')) {
                container.classList.add('concerned');
                if (panel) panel.classList.add('concerned');
            } else if (lowerText.includes('pilot') || lowerText.includes('üöÄ') ||
                       lowerText.includes('eseguito') || lowerText.includes('completato')) {
                container.classList.add('excited');
                if (panel) panel.classList.add('excited');
            }
        }
        
        // Create voice message waveform visualization
        function createVoiceWaveform(duration = 10) {
            const bars = [];
            const numBars = Math.floor(duration * 3);
            
            for (let i = 0; i < numBars; i++) {
                // Generate random but smooth waveform
                const height = 4 + Math.sin(i * 0.5) * 8 + Math.random() * 10;
                bars.push(Math.floor(height));
            }
            
            return bars;
        }
        
        function startBlinking() {
            if (blinkInterval) clearInterval(blinkInterval);
            
            blinkInterval = setInterval(() => {
                triggerBlink();
            }, 3000 + Math.random() * 4000); // Random blink every 3-7 seconds
        }
        
        function triggerBlink() {
            const leftEye = document.getElementById('eyeLeft');
            const rightEye = document.getElementById('eyeRight');
            const miniLeftEye = document.getElementById('miniEyeLeft');
            const miniRightEye = document.getElementById('miniEyeRight');
            
            // Blink main avatar
            if (leftEye && rightEye) {
                leftEye.classList.add('blinking');
                rightEye.classList.add('blinking');
                
                setTimeout(() => {
                    leftEye.classList.remove('blinking');
                    rightEye.classList.remove('blinking');
                }, 150);
            }
            
            // Blink mini avatar too
            if (miniLeftEye && miniRightEye) {
                miniLeftEye.classList.add('blinking');
                miniRightEye.classList.add('blinking');
                
                setTimeout(() => {
                    miniLeftEye.classList.remove('blinking');
                    miniRightEye.classList.remove('blinking');
                }, 150);
            }
        }
        
        function setAvatarState(state) {
            const container = document.getElementById('avatar3D');
            const mouth = document.getElementById('avatarMouth');
            const indicator = document.getElementById('avatarStateIndicator');
            const stateText = document.getElementById('avatarStateText');
            
            if (!container || !mouth) return;
            
            // Remove all state classes
            container.classList.remove('idle', 'listening', 'speaking', 'thinking');
            mouth.classList.remove('idle', 'speaking');
            if (indicator) {
                indicator.classList.remove('idle', 'listening', 'speaking', 'thinking', 'pilot');
            }
            
            avatarState = state;
            
            // Sync with mini avatar panel
            updateChatAvatarPanel(state);
            
            // State labels for display
            const stateLabels = {
                'idle': 'STANDBY',
                'listening': 'ASCOLTO',
                'speaking': 'RISPOSTA',
                'thinking': 'ANALISI'
            };
            
            switch(state) {
                case 'listening':
                    container.classList.add('listening');
                    mouth.classList.add('idle');
                    if (indicator) indicator.classList.add('listening');
                    break;
                    
                case 'speaking':
                    container.classList.add('speaking');
                    mouth.classList.add('speaking');
                    if (indicator) indicator.classList.add('speaking');
                    break;
                    
                case 'thinking':
                    container.classList.add('thinking');
                    mouth.classList.add('idle');
                    if (indicator) indicator.classList.add('thinking');
                    break;
                    
                case 'idle':
                default:
                    container.classList.add('idle');
                    mouth.classList.add('idle');
                    if (indicator) indicator.classList.add('idle');
                    break;
            }
            
            // Update state text
            if (stateText) {
                stateText.textContent = stateLabels[state] || 'STANDBY';
            }
            
            // Add pilot indicator if in pilot mode
            if (pilotModeActive && indicator) {
                indicator.classList.add('pilot');
                if (stateText && state === 'idle') {
                    stateText.textContent = 'PILOT ATTIVO';
                }
            }
            
            console.log(`ü§ñ Avatar state: ${state}`);
        }
        
        // Initialize avatar on load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initAvatar3D, 500);
        });

        // Inizializza Web Speech API
        function initVoiceRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('Speech Recognition non supportato');
                document.getElementById('voiceStatus').textContent = '‚ö†Ô∏è Microfono non supportato dal browser';
                document.getElementById('voiceBtn').disabled = true;
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            
            recognition.lang = 'it-IT';
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                isListening = true;
                document.getElementById('voiceBtn').classList.add('listening');
                document.getElementById('voiceBtn').textContent = 'üî¥ LISTENING';
                document.getElementById('voiceStatus').textContent = 'üé§ VOICE INPUT ACTIVE...';
                console.log('üé§ Microfono attivo');
                // Avatar 3D: stato ascolto
                setAvatarState('listening');
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (interimTranscript) {
                    document.getElementById('voiceStatus').textContent = `üé§ "${interimTranscript}"`;
                    lastSpeechTime = Date.now();
                    
                    // In hands-free mode, show interim in indicator
                    if (handsFreeMode) {
                        updateHandsFreeIndicator('listening', interimTranscript);
                    }
                }

                if (finalTranscript) {
                    console.log('üìù Riconosciuto:', finalTranscript);
                    const normalizedText = finalTranscript.toLowerCase().trim();
                    
                    // Log voice recognition to Activity Log
                    addLogEntry('voice', `Voce riconosciuta: "${finalTranscript.substring(0, 50)}${finalTranscript.length > 50 ? '...' : ''}"`, 'üé§');
                    
                    // Update voice activity meter
                    updateVoiceActivityMeter(80);
                    setTimeout(() => updateVoiceActivityMeter(0), 500);
                    
                    // ========== HANDS-FREE: Check for sleep phrases ==========
                    if (handsFreeMode && checkSleepPhrase(normalizedText)) {
                        deactivateHandsFree();
                        endContinuousConversation();
                        speak('Modalit√† hands-free disattivata. A presto!');
                        playFeedbackSound('success');
                        return;
                    }
                    
                    // ========== HANDS-FREE: Check for wake word ==========
                    if (handsFreeMode && !awaitingCommand) {
                        // IMPORTANT: Always check for pilot deactivation first (even without wake word)
                        if (pilotModeActive) {
                            const pilotAction = checkPilotActivation(normalizedText);
                            if (pilotAction === 'deactivate') {
                                addMessage(finalTranscript, 'user');
                                deactivatePilotMode('voice');
                                return;
                            }
                        }
                        
                        // STEP 10: Check if conversation is active (no wake word needed)
                        if (conversationActive) {
                            // Conversazione attiva: processa direttamente il comando
                            console.log('üí¨ Conversazione continua, processo direttamente:', normalizedText);
                            awaitingCommand = true;
                            processHandsFreeCommand(normalizedText);
                            return;
                        }
                        
                        if (checkWakeWord(normalizedText)) {
                            awaitingCommand = true;
                            updateHandsFreeIndicator('awaiting');
                            speak('Dimmi');
                            showAdvantagesPanel(); // Mostra vantaggi la prima volta
                            // Estrai comando dopo wake word se presente
                            const commandAfterWake = extractCommandAfterWakeWord(normalizedText);
                            if (commandAfterWake) {
                                processHandsFreeCommand(commandAfterWake);
                            }
                            return;
                        } else {
                            // Non √® un wake word, ignora (ambient noise)
                            console.log('üëÇ Hands-free: in attesa di wake word, ignorato:', normalizedText);
                            return;
                        }
                    }
                    
                    // ========== HANDS-FREE: Process command ==========
                    if (handsFreeMode && awaitingCommand) {
                        processHandsFreeCommand(normalizedText);
                        return;
                    }
                    
                    document.getElementById('voiceStatus').textContent = '‚úÖ Comando ricevuto';
                    
                    // Check for pilot mode activation/deactivation phrases
                    const pilotAction = checkPilotActivation(finalTranscript);
                    
                    if (pilotAction === 'activate') {
                        addMessage(finalTranscript, 'user');
                        activatePilotMode('voice');
                        return;
                    } else if (pilotAction === 'deactivate') {
                        addMessage(finalTranscript, 'user');
                        deactivatePilotMode('voice');
                        return;
                    }
                    
                    // If in pilot mode, execute as pilot command
                    if (pilotModeActive) {
                        addMessage(finalTranscript, 'user');
                        executePilotCommand(finalTranscript);
                    } else {
                        // Normal voice command
                        sendVoiceCommand(finalTranscript);
                    }
                    
                    // In pilot mode or hands-free, keep listening continuously
                    if (pilotModeActive || handsFreeMode) {
                        continuousMode = true;
                    } else if (!continuousMode) {
                        setTimeout(() => {
                            if (recognition && isListening) {
                                recognition.stop();
                            }
                        }, 500);
                    }
                }
            };

            recognition.onerror = (event) => {
                console.error('Errore riconoscimento vocale:', event.error);
                if (event.error === 'no-speech') {
                    document.getElementById('voiceStatus').textContent = 'üîá Nessun input vocale rilevato';
                } else if (event.error === 'not-allowed') {
                    document.getElementById('voiceStatus').textContent = 'üö´ Permesso microfono negato';
                    isListening = false;
                    document.getElementById('voiceBtn').classList.remove('listening');
                    document.getElementById('voiceBtn').textContent = 'üé§ Voce';
                } else {
                    document.getElementById('voiceStatus').textContent = `‚ùå Errore: ${event.error}`;
                }
            };

            recognition.onend = () => {
                isListening = false;
                document.getElementById('voiceBtn').classList.remove('listening');
                document.getElementById('voiceBtn').textContent = 'üé§ VOICE';
                
                // Avatar 3D: torna a idle (se non sta parlando)
                if (avatarState !== 'speaking') {
                    setAvatarState('idle');
                }
                
                // ========== ANTI-ECHO: Non riavviare se Gideon sta parlando ==========
                if (speechSynthesis.speaking) {
                    console.log('üîá Mic non riavviato - Gideon sta ancora parlando');
                    return; // Non riavviare, verr√† fatto da utterance.onend
                }
                
                if (continuousMode) {
                    // Riavvia automaticamente in modalit√† continua
                    setTimeout(() => {
                        // Doppio controllo: se nel frattempo Gideon ha iniziato a parlare, non riavviare
                        if (continuousMode && !speechSynthesis.speaking) {
                            startVoiceRecognition();
                        }
                    }, 100);
                } else {
                    document.getElementById('voiceStatus').textContent = 'MIC OFFLINE';
                }
            };

            return true;
        }

        function toggleVoice() {
            if (!recognition) {
                if (!initVoiceRecognition()) {
                    return;
                }
            }

            if (isListening) {
                stopVoiceRecognition();
            } else {
                startVoiceRecognition();
            }
        }

        function startVoiceRecognition() {
            // ========== ANTI-ECHO: Non avviare se Gideon sta parlando ==========
            if (speechSynthesis.speaking) {
                console.log('üîá Mic non avviato - Gideon sta parlando');
                document.getElementById('voiceStatus').textContent = 'üó£Ô∏è Aspetta che Gideon finisca...';
                return;
            }
            
            if (recognition && !isListening) {
                try {
                    recognition.start();
                    continuousMode = true;
                } catch (error) {
                    console.error('Errore avvio microfono:', error);
                    // Se il riconoscimento √® gi√† in corso, ignora l'errore
                    if (error.message && error.message.includes('already started')) {
                        console.log('Riconoscimento vocale gi√† attivo');
                        isListening = true;
                        return;
                    }
                    document.getElementById('voiceStatus').textContent = '‚ùå Errore avvio microfono';
                }
            }
        }

        function stopVoiceRecognition() {
            if (recognition && isListening) {
                continuousMode = false;
                recognition.stop();
                document.getElementById('voiceStatus').textContent = '‚úã Microfono disattivato';
            }
        }

        // ========== HANDS-FREE MODE FUNCTIONS ==========
        
        function toggleHandsFree() {
            if (handsFreeMode) {
                deactivateHandsFree();
            } else {
                activateHandsFree();
            }
        }
        
        function activateHandsFree() {
            handsFreeMode = true;
            awaitingCommand = false;
            
            // Resume AudioContext if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Inizializza riconoscimento se non presente
            if (!recognition) {
                if (!initVoiceRecognition()) {
                    handsFreeMode = false;
                    return;
                }
            }
            
            // Avvia ascolto continuo
            continuousMode = true;
            if (!isListening) {
                startVoiceRecognition();
            }
            
            // Aggiorna UI
            const handsFreeBtn = document.getElementById('handsFreeBtn');
            handsFreeBtn.classList.add('active');
            handsFreeBtn.textContent = '‚úÖ HANDS-FREE ON';
            
            const voiceBtn = document.getElementById('voiceBtn');
            voiceBtn.classList.add('hands-free');
            
            document.getElementById('handsFreeIndicator').classList.add('active');
            updateHandsFreeIndicator('idle');
            
            document.getElementById('voiceStatus').textContent = 'üôå HANDS-FREE: Di\' "Gideon" per iniziare';
            
            // Feedback sonoro
            playFeedbackSound('success');
            
            // Annuncia attivazione
            speak('Modalit√† hands-free attivata. Dimmi Gideon quando hai bisogno di me.');
            
            console.log('üôå Hands-Free Mode ATTIVATO');
            logEvent('HANDS_FREE', { action: 'activated' });
        }
        
        function deactivateHandsFree() {
            handsFreeMode = false;
            awaitingCommand = false;
            endContinuousConversation();
            
            // Feedback sonoro
            playFeedbackSound('process');
            
            // Se non siamo in pilot mode, ferma l'ascolto
            if (!pilotModeActive) {
                continuousMode = false;
                if (isListening) {
                    stopVoiceRecognition();
                }
            }
            
            // Aggiorna UI
            const handsFreeBtn = document.getElementById('handsFreeBtn');
            handsFreeBtn.classList.remove('active');
            handsFreeBtn.textContent = 'üôå HANDS-FREE';
            
            const voiceBtn = document.getElementById('voiceBtn');
            voiceBtn.classList.remove('hands-free');
            
            document.getElementById('handsFreeIndicator').classList.remove('active');
            document.getElementById('voiceStatus').textContent = 'MIC OFFLINE';
            
            console.log('üôå Hands-Free Mode DISATTIVATO');
            logEvent('HANDS_FREE', { action: 'deactivated' });
        }
        
        function checkWakeWord(text) {
            const normalized = text.toLowerCase().trim();
            return WAKE_WORDS.some(wake => normalized.includes(wake));
        }
        
        function checkSleepPhrase(text) {
            const normalized = text.toLowerCase().trim();
            return SLEEP_PHRASES.some(sleep => normalized.includes(sleep));
        }
        
        function extractCommandAfterWakeWord(text) {
            const normalized = text.toLowerCase().trim();
            for (const wake of WAKE_WORDS) {
                const idx = normalized.indexOf(wake);
                if (idx !== -1) {
                    const afterWake = text.substring(idx + wake.length).trim();
                    if (afterWake.length > 2) {
                        return afterWake;
                    }
                }
            }
            return null;
        }
        
        function processHandsFreeCommand(command) {
            console.log('üéØ Hands-Free comando:', command);
            
            // Reset stato
            awaitingCommand = false;
            updateHandsFreeIndicator('processing');
            
            // ========== STEP 10.5: CONTROLLO TOTALE APP VIA VOCE ==========
            const voiceControl = processVoiceAppControl(command);
            if (voiceControl.handled) {
                addMessage(command, 'user');
                if (voiceControl.response) {
                    addMessage(voiceControl.response, 'gideon');
                    speak(voiceControl.speak || voiceControl.response.replace(/<[^>]*>/g, ''));
                }
                playFeedbackSound('success');
                startContinuousConversation();
                setTimeout(() => {
                    if (handsFreeMode) updateHandsFreeIndicator('idle');
                }, 500);
                return;
            }
            
            // Check per comandi pilota
            const pilotAction = checkPilotActivation(command);
            if (pilotAction === 'activate') {
                addMessage(command, 'user');
                activatePilotMode('voice');
                return;
            } else if (pilotAction === 'deactivate') {
                addMessage(command, 'user');
                deactivatePilotMode('voice');
                return;
            }
            
            // Invia comando
            if (pilotModeActive) {
                addMessage(command, 'user');
                executePilotCommand(command);
            } else {
                sendVoiceCommand(command);
            }
            
            // Torna in attesa wake word dopo un delay
            setTimeout(() => {
                if (handsFreeMode) {
                    updateHandsFreeIndicator('idle');
                }
            }, 500);
            
            // Step 10: Attiva conversazione continua
            startContinuousConversation();
        }
        
        // ========== STEP 10.5: VOICE APP CONTROL SYSTEM ==========
        const VOICE_COMMANDS = {
            // Livelli
            level: {
                patterns: [
                    /modalit[a√†]\s*(normal|normale|base)/i,
                    /livello\s*(normal|normale|base)/i,
                    /passa\s*a\s*(normal|normale)/i
                ],
                action: () => { selectLevel('normal'); return { handled: true, response: 'üü¢ Livello NORMAL attivato', speak: 'Modalit√† normale attivata' }; }
            },
            levelAdvanced: {
                patterns: [
                    /modalit[a√†]\s*(advanced|avanzat[ao])/i,
                    /livello\s*(advanced|avanzat[ao])/i,
                    /passa\s*a\s*(advanced|avanzat[ao])/i,
                    /analisi\s*profonda/i
                ],
                action: () => { selectLevel('advanced'); return { handled: true, response: '‚ö° Livello ADVANCED attivato', speak: 'Modalit√† avanzata attivata' }; }
            },
            levelPilot: {
                patterns: [
                    /modalit[a√†]\s*pilot/i,
                    /livello\s*pilot/i,
                    /autonomia\s*(totale|completa|massima)/i
                ],
                action: () => { selectLevel('pilot'); return { handled: true, response: 'üöÄ Livello PILOT attivato', speak: 'Modalit√† pilota attivata. Autonomia totale.' }; }
            },
            
            // TTS Control
            ttsOn: {
                patterns: [
                    /attiva\s*(la\s*)?voce/i,
                    /abilita\s*(la\s*)?voce/i,
                    /accendi\s*(la\s*)?voce/i,
                    /parla/i,
                    /voice\s*on/i
                ],
                action: () => { 
                    if (!ttsEnabled) toggleTTS();
                    return { handled: true, response: 'üîä Voce attivata', speak: 'Voce attivata' }; 
                }
            },
            ttsOff: {
                patterns: [
                    /disattiva\s*(la\s*)?voce/i,
                    /disabilita\s*(la\s*)?voce/i,
                    /spegni\s*(la\s*)?voce/i,
                    /silenzio/i,
                    /zitto/i,
                    /muto/i,
                    /voice\s*off/i
                ],
                action: () => { 
                    if (ttsEnabled) toggleTTS();
                    return { handled: true, response: 'üîá Voce disattivata' }; 
                }
            },
            
            // Hands-free control
            handsFreeOff: {
                patterns: [
                    /disattiva\s*hands[\s-]?free/i,
                    /esci\s*(dalla\s*)?modalit[a√†]\s*continua/i,
                    /stop\s*listening/i
                ],
                action: () => { 
                    deactivateHandsFree();
                    return { handled: true, response: '‚úã Modalit√† hands-free disattivata', speak: 'Hands-free disattivato' }; 
                }
            },
            
            // Info & Status
            status: {
                patterns: [
                    /stato\s*(del\s*)?(sistema|gideon)/i,
                    /come\s*stai/i,
                    /system\s*status/i,
                    /qual\s*[e√®]\s*(lo\s*)?stato/i
                ],
                action: () => {
                    const level = GIDEON_LEVELS[currentLevel];
                    const status = `üìä <strong>Stato Sistema:</strong><br>
‚Ä¢ Livello: ${level.icon} ${level.name}<br>
‚Ä¢ Autonomia: ${Math.round(level.autonomy * 100)}%<br>
‚Ä¢ Voce: ${ttsEnabled ? 'üîä Attiva' : 'üîá Disattiva'}<br>
‚Ä¢ Hands-Free: ${handsFreeMode ? '‚úÖ Attivo' : '‚ùå Disattivo'}<br>
‚Ä¢ Pilot Mode: ${pilotModeActive ? 'üöÄ Attivo' : '‚ö´ Disattivo'}`;
                    return { handled: true, response: status, speak: `Sono in modalit√† ${level.name} con autonomia al ${Math.round(level.autonomy * 100)} percento` };
                }
            },
            
            // Help
            help: {
                patterns: [
                    /aiuto/i,
                    /help/i,
                    /comandi\s*(vocali|disponibili)?/i,
                    /cosa\s*puoi\s*fare/i,
                    /le\s*tue\s*funzioni/i
                ],
                action: () => {
                    const helpText = `üé§ <strong>Comandi Vocali Disponibili:</strong><br><br>
üìå <strong>LIVELLI:</strong><br>
‚Ä¢ "Modalit√† normale" / "Modalit√† avanzata" / "Modalit√† pilot"<br><br>
üîä <strong>VOCE:</strong><br>
‚Ä¢ "Attiva voce" / "Disattiva voce" / "Silenzio"<br><br>
üìä <strong>INFO:</strong><br>
‚Ä¢ "Stato sistema" / "Chi sei?" / "Che ore sono?"<br><br>
üß≠ <strong>NAVIGAZIONE UI:</strong><br>
‚Ä¢ "Apri log" / "Chiudi log" / "Mostra metriche"<br>
‚Ä¢ "Scroll su" / "Scroll gi√π" / "Vai all'inizio"<br>
‚Ä¢ "Schermo intero" / "Cambia tema"<br><br>
üöÄ <strong>AZIONI:</strong><br>
‚Ä¢ "Pulisci chat" / "Cancella messaggi"<br>
‚Ä¢ "Ferma" / "Stop" (interrompe la voce)<br><br>
üí° Di' "Gideon" seguito dal comando!`;
                    return { handled: true, response: helpText, speak: 'Puoi navigare l\'interfaccia con la voce: apri log, mostra metriche, scroll su e gi√π, schermo intero, e cambia tema. Di Gideon seguito dal comando.' };
                }
            },
            
            // Time
            time: {
                patterns: [
                    /che\s*ore?\s*sono/i,
                    /ora\s*attuale/i,
                    /dimmi\s*l[\'\']?ora/i,
                    /what\s*time/i
                ],
                action: () => {
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
                    const dateStr = now.toLocaleDateString('it-IT', { weekday: 'long', day: 'numeric', month: 'long' });
                    return { handled: true, response: `üïê Sono le <strong>${timeStr}</strong><br>üìÖ ${dateStr}`, speak: `Sono le ${timeStr}` };
                }
            },
            
            // Clear chat
            clearChat: {
                patterns: [
                    /pulisci\s*(la\s*)?chat/i,
                    /cancella\s*(i\s*)?messaggi/i,
                    /clear\s*chat/i,
                    /svuota\s*(la\s*)?chat/i
                ],
                action: () => {
                    document.getElementById('messages').innerHTML = '';
                    return { handled: true, response: 'üßπ Chat pulita!', speak: 'Chat pulita' };
                }
            },
            
            // Stop speaking
            stop: {
                patterns: [
                    /^stop$/i,
                    /^ferma(ti)?$/i,
                    /^basta$/i,
                    /smetti\s*(di\s*parlare)?/i
                ],
                action: () => {
                    if (speechSynthesis.speaking) {
                        speechSynthesis.cancel();
                    }
                    setAvatarState('idle');
                    return { handled: true, response: '‚èπÔ∏è Fermato', speak: '' };
                }
            },
            
            // Repeat last
            repeat: {
                patterns: [
                    /ripeti/i,
                    /di[\'\']?\s*di\s*nuovo/i,
                    /repeat/i,
                    /ancora/i
                ],
                action: () => {
                    const lastGideonMsg = document.querySelector('.message.gideon:last-of-type .text-content, .message.gideon:last-of-type .message-text-content');
                    if (lastGideonMsg) {
                        const text = lastGideonMsg.textContent;
                        speak(text);
                        return { handled: true, response: 'üîÑ Ripeto...', speak: text };
                    }
                    return { handled: true, response: '‚ùå Nessun messaggio da ripetere', speak: 'Non ho messaggi da ripetere' };
                }
            },
            
            // Thanks
            thanks: {
                patterns: [
                    /grazie/i,
                    /thank/i,
                    /perfetto/i,
                    /ottimo/i,
                    /bravo/i
                ],
                action: () => {
                    const responses = [
                        'Di nulla! Sono qui per aiutarti.',
                        'Prego! A tua disposizione.',
                        '√à un piacere assisterti!',
                        'Felice di essere utile!'
                    ];
                    const resp = responses[Math.floor(Math.random() * responses.length)];
                    return { handled: true, response: `üòä ${resp}`, speak: resp };
                }
            },
            
            // ===== NAVIGAZIONE UI =====
            
            // Apri pannello log
            openLog: {
                patterns: [
                    /apri\s*(il\s*)?(pannello\s*)?log/i,
                    /mostra\s*(il\s*)?(pannello\s*)?log/i,
                    /visualizza\s*(il\s*)?log/i,
                    /activity\s*log/i
                ],
                action: () => {
                    const logPanel = document.getElementById('activityLogPanel');
                    if (logPanel) {
                        logPanel.classList.add('visible');
                        return { handled: true, response: 'üìã Pannello Activity Log aperto', speak: 'Ho aperto il pannello dei log' };
                    }
                    return { handled: true, response: 'üìã Pannello log non disponibile', speak: 'Pannello log non ancora disponibile' };
                }
            },
            
            // Chiudi pannello log
            closeLog: {
                patterns: [
                    /chiudi\s*(il\s*)?(pannello\s*)?log/i,
                    /nascondi\s*(il\s*)?(pannello\s*)?log/i,
                    /esci\s*(dal\s*)?log/i
                ],
                action: () => {
                    const logPanel = document.getElementById('activityLogPanel');
                    if (logPanel) {
                        logPanel.classList.remove('visible');
                        return { handled: true, response: 'üìã Pannello Activity Log chiuso', speak: 'Pannello log chiuso' };
                    }
                    return { handled: true, response: '‚úÖ OK' };
                }
            },
            
            // Mostra metriche/statistiche
            showMetrics: {
                patterns: [
                    /mostra\s*(le\s*)?metriche/i,
                    /apri\s*(le\s*)?metriche/i,
                    /statistiche/i,
                    /mostra\s*(le\s*)?stats/i,
                    /performance/i
                ],
                action: () => {
                    const metricsPanel = document.getElementById('metricsPanel');
                    if (metricsPanel) {
                        metricsPanel.classList.toggle('visible');
                        const isVisible = metricsPanel.classList.contains('visible');
                        return { handled: true, response: isVisible ? 'üìä Pannello metriche aperto' : 'üìä Pannello metriche chiuso', speak: isVisible ? 'Ecco le metriche' : 'Metriche chiuse' };
                    }
                    // Fallback: mostra metriche inline
                    const memUsed = (performance.memory?.usedJSHeapSize / 1024 / 1024).toFixed(1) || 'N/A';
                    const uptime = Math.floor((Date.now() - window.sessionStartTime) / 1000 / 60);
                    const metrics = `üìä <strong>Metriche Sistema:</strong><br>
‚Ä¢ Memoria JS: ${memUsed} MB<br>
‚Ä¢ Sessione attiva: ${uptime} minuti<br>
‚Ä¢ Messaggi chat: ${document.querySelectorAll('.message').length}<br>
‚Ä¢ TTS: ${ttsEnabled ? 'üîä Attivo' : 'üîá Disattivo'}`;
                    return { handled: true, response: metrics, speak: `Sessione attiva da ${uptime} minuti` };
                }
            },
            
            // Scroll chat su
            scrollUp: {
                patterns: [
                    /scroll\s*(in\s*)?(su|alto)/i,
                    /scorri\s*(in\s*)?(su|alto)/i,
                    /vai\s*(in\s*)?su/i,
                    /torna\s*su/i,
                    /scroll\s*up/i
                ],
                action: () => {
                    const messagesDiv = document.getElementById('messages');
                    if (messagesDiv) {
                        messagesDiv.scrollBy({ top: -300, behavior: 'smooth' });
                        return { handled: true, response: '‚¨ÜÔ∏è Scroll su', speak: '' };
                    }
                    return { handled: true, response: '‚úÖ OK' };
                }
            },
            
            // Scroll chat gi√π
            scrollDown: {
                patterns: [
                    /scroll\s*(in\s*)?(gi[u√π]|basso)/i,
                    /scorri\s*(in\s*)?(gi[u√π]|basso)/i,
                    /vai\s*(in\s*)?(gi[u√π]|basso)/i,
                    /scroll\s*down/i
                ],
                action: () => {
                    const messagesDiv = document.getElementById('messages');
                    if (messagesDiv) {
                        messagesDiv.scrollBy({ top: 300, behavior: 'smooth' });
                        return { handled: true, response: '‚¨áÔ∏è Scroll gi√π', speak: '' };
                    }
                    return { handled: true, response: '‚úÖ OK' };
                }
            },
            
            // Vai all'inizio della chat
            scrollTop: {
                patterns: [
                    /vai\s*(all[\'\'])?inizio/i,
                    /torna\s*(all[\'\'])?inizio/i,
                    /primo\s*messaggio/i,
                    /scroll\s*top/i
                ],
                action: () => {
                    const messagesDiv = document.getElementById('messages');
                    if (messagesDiv) {
                        messagesDiv.scrollTo({ top: 0, behavior: 'smooth' });
                        return { handled: true, response: '‚¨ÜÔ∏è Tornato all\'inizio', speak: 'Eccoci all\'inizio della chat' };
                    }
                    return { handled: true, response: '‚úÖ OK' };
                }
            },
            
            // Vai alla fine della chat
            scrollBottom: {
                patterns: [
                    /vai\s*(alla\s*)?fine/i,
                    /ultimo\s*messaggio/i,
                    /messaggi\s*recenti/i,
                    /scroll\s*bottom/i
                ],
                action: () => {
                    const messagesDiv = document.getElementById('messages');
                    if (messagesDiv) {
                        messagesDiv.scrollTo({ top: messagesDiv.scrollHeight, behavior: 'smooth' });
                        return { handled: true, response: '‚¨áÔ∏è Ultimo messaggio', speak: 'Ecco gli ultimi messaggi' };
                    }
                    return { handled: true, response: '‚úÖ OK' };
                }
            },
            
            // Toggle comandi vocali panel
            toggleVoiceCommands: {
                patterns: [
                    /mostra\s*(i\s*)?comandi\s*vocali/i,
                    /apri\s*comandi/i,
                    /nascondi\s*comandi/i,
                    /chiudi\s*comandi/i
                ],
                action: () => {
                    const panel = document.getElementById('voiceCommandsPanel');
                    if (panel) {
                        panel.classList.toggle('visible');
                        const isVisible = panel.classList.contains('visible');
                        return { handled: true, response: isVisible ? 'üé§ Pannello comandi aperto' : 'üé§ Pannello comandi chiuso', speak: isVisible ? 'Ecco i comandi vocali' : 'Comandi nascosti' };
                    }
                    return { handled: true, response: '‚úÖ OK' };
                }
            },
            
            // Tema scuro/chiaro
            toggleTheme: {
                patterns: [
                    /tema\s*(scuro|dark)/i,
                    /tema\s*(chiaro|light)/i,
                    /cambia\s*tema/i,
                    /dark\s*mode/i,
                    /light\s*mode/i
                ],
                action: () => {
                    document.body.classList.toggle('light-theme');
                    const isLight = document.body.classList.contains('light-theme');
                    return { handled: true, response: isLight ? '‚òÄÔ∏è Tema chiaro attivato' : 'üåô Tema scuro attivato', speak: isLight ? 'Tema chiaro' : 'Tema scuro' };
                }
            },
            
            // Fullscreen toggle
            toggleFullscreen: {
                patterns: [
                    /schermo\s*intero/i,
                    /fullscreen/i,
                    /esci\s*(da\s*)?fullscreen/i,
                    /massimizza/i
                ],
                action: () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                        return { handled: true, response: 'üñ•Ô∏è Schermo intero attivato', speak: 'Schermo intero' };
                    } else {
                        document.exitFullscreen();
                        return { handled: true, response: 'üñ•Ô∏è Uscito da schermo intero', speak: 'Schermo normale' };
                    }
                }
            },
            
            // Focus input
            focusInput: {
                patterns: [
                    /focus\s*(sulla\s*)?chat/i,
                    /scrivi\s*messaggio/i,
                    /attiva\s*input/i,
                    /digita/i
                ],
                action: () => {
                    const input = document.getElementById('messageInput');
                    if (input) {
                        input.focus();
                        return { handled: true, response: '‚å®Ô∏è Input attivato - scrivi pure!', speak: 'Pronto per scrivere' };
                    }
                    return { handled: true, response: '‚úÖ OK' };
                }
            }
        };
        
        function processVoiceAppControl(command) {
            const lowerCmd = command.toLowerCase().trim();
            
            // Check for Gideon explanation first
            if (checkExplanationCommand(lowerCmd)) {
                explainGideon();
                return { handled: true };
            }
            
            // Check each command category
            for (const [name, cmd] of Object.entries(VOICE_COMMANDS)) {
                for (const pattern of cmd.patterns) {
                    if (pattern.test(lowerCmd)) {
                        console.log(`üéÆ Voice command matched: ${name}`);
                        return cmd.action();
                    }
                }
            }
            
            return { handled: false };
        }
        
        function updateHandsFreeIndicator(state, text = '') {
            const indicator = document.getElementById('handsFreeIndicator');
            const textEl = document.getElementById('handsFreeText');
            const audioVisualizer = document.getElementById('audioVisualizer');
            
            indicator.classList.remove('awaiting');
            audioVisualizer?.classList.remove('active');
            
            switch(state) {
                case 'idle':
                    textEl.textContent = conversationActive ? 'üí¨ Continua...' : 'üé§ Di\' "Gideon"...';
                    break;
                case 'awaiting':
                    indicator.classList.add('awaiting');
                    audioVisualizer?.classList.add('active');
                    textEl.textContent = 'üëÇ Ti ascolto...';
                    playFeedbackSound('listen');
                    break;
                case 'listening':
                    indicator.classList.add('awaiting');
                    audioVisualizer?.classList.add('active');
                    textEl.textContent = text ? `üé§ "${text.substring(0, 25)}..."` : 'üé§ Sto sentendo...';
                    break;
                case 'processing':
                    textEl.textContent = '‚öôÔ∏è Elaboro...';
                    playFeedbackSound('process');
                    break;
                case 'responding':
                    textEl.textContent = 'üí¨ Rispondo...';
                    break;
            }
        }
        
        // ========== STEP 10: CONVERSAZIONE CONTINUA ==========
        
        function startContinuousConversation() {
            if (!conversationActive) {
                conversationActive = true;
                conversationStartTime = Date.now();
                document.getElementById('conversationState').classList.add('active');
                startConversationTimer();
            }
            
            // Reset timeout per conversazione continua
            clearTimeout(continuousConversationTimeout);
            continuousConversationTimeout = setTimeout(() => {
                endContinuousConversation();
            }, CONTINUOUS_CONVERSATION_DELAY);
        }
        
        function endContinuousConversation() {
            conversationActive = false;
            conversationStartTime = null;
            document.getElementById('conversationState').classList.remove('active');
            if (conversationTimer) {
                clearInterval(conversationTimer);
                conversationTimer = null;
            }
            if (handsFreeMode) {
                updateHandsFreeIndicator('idle');
            }
        }
        
        function startConversationTimer() {
            if (conversationTimer) clearInterval(conversationTimer);
            
            conversationTimer = setInterval(() => {
                if (conversationStartTime) {
                    const elapsed = Date.now() - conversationStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('conversationTime').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        function updateVoiceActivityMeter(level) {
            voiceActivityLevel = Math.min(100, Math.max(0, level));
            const fill = document.getElementById('voiceMeterFill');
            const label = document.getElementById('voiceMeterLabel');
            if (fill) fill.style.width = voiceActivityLevel + '%';
            if (label) label.textContent = Math.round(voiceActivityLevel) + '%';
        }
        
        // ========== AUDIO FEEDBACK ==========
        
        function playFeedbackSound(type) {
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'listen':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.15);
                        break;
                    case 'process':
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.12);
                        break;
                    case 'success':
                        oscillator.frequency.setValueAtTime(523, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'error':
                        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(150, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                }
                
                showSoundFeedback(type);
            } catch (e) {
                console.log('Audio feedback non disponibile:', e);
            }
        }
        
        function showSoundFeedback(type) {
            const feedback = document.getElementById('soundFeedback');
            if (!feedback) return;
            
            const icons = {
                'listen': 'üëÇ',
                'process': '‚öôÔ∏è',
                'success': '‚úÖ',
                'error': '‚ùå'
            };
            
            feedback.textContent = icons[type] || 'üéµ';
            feedback.classList.add('show');
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 500);
        }
        
        function showAdvantagesPanel() {
            document.getElementById('advantagesPanel').classList.add('show');
        }
        
        function hideAdvantagesPanel() {
            document.getElementById('advantagesPanel').classList.remove('show');
        }
        
        // ========== SECURITY BADGE FUNCTIONS ==========
        let securityStatus = {
            connection: 'secure',
            session: 'active',
            encryption: 'TLS 1.3',
            lastCheck: new Date(),
            auditLog: true
        };
        
        function showSecurityDetails() {
            let popup = document.getElementById('securityPopup');
            
            if (!popup) {
                // Create popup if it doesn't exist
                popup = document.createElement('div');
                popup.id = 'securityPopup';
                popup.className = 'security-popup';
                popup.innerHTML = `
                    <div class="security-popup-header">üîí SECURITY STATUS</div>
                    <div class="security-item">
                        <span class="security-item-label">Connessione</span>
                        <span class="security-item-value ok" id="secConnStatus">ENCRYPTED</span>
                    </div>
                    <div class="security-item">
                        <span class="security-item-label">Sessione</span>
                        <span class="security-item-value ok" id="secSessionStatus">ACTIVE</span>
                    </div>
                    <div class="security-item">
                        <span class="security-item-label">Protocollo</span>
                        <span class="security-item-value" id="secProtocol">WebSocket</span>
                    </div>
                    <div class="security-item">
                        <span class="security-item-label">Audit Log</span>
                        <span class="security-item-value ok" id="secAudit">ENABLED</span>
                    </div>
                    <div class="security-item">
                        <span class="security-item-label">Ultimo check</span>
                        <span class="security-item-value" id="secLastCheck">--:--</span>
                    </div>
                `;
                document.getElementById('securityBadge').appendChild(popup);
                
                // Close on click outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.security-badge')) {
                        popup.classList.remove('visible');
                    }
                });
            }
            
            // Update values
            const now = new Date();
            document.getElementById('secLastCheck').textContent = now.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
            
            // Toggle visibility
            popup.classList.toggle('visible');
            
            // Log security check
            addLogEntry('system', 'Security status verificato', 'üîí');
        }
        
        function updateSecurityBadge(status) {
            const badge = document.getElementById('securityBadge');
            const text = document.getElementById('securityText');
            const icon = badge.querySelector('.security-icon');
            
            badge.classList.remove('secure', 'warning');
            
            if (status === 'secure') {
                badge.classList.add('secure');
                text.textContent = 'SECURE';
                icon.textContent = 'üîí';
            } else if (status === 'warning') {
                badge.classList.add('warning');
                text.textContent = 'CHECK';
                icon.textContent = '‚ö†Ô∏è';
            }
        }
        
        // Initialize security on load
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial security status based on connection
            setTimeout(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    updateSecurityBadge('secure');
                }
            }, 2000);
        });
        
        // ========== FEEDBACK FUNCTIONS ==========
        let feedbackData = [];
        
        function sendFeedback(msgId, type, buttonEl) {
            // Get the feedback container
            const feedbackContainer = buttonEl.closest('.message-feedback');
            const buttons = feedbackContainer.querySelectorAll('.feedback-btn');
            
            // Mark selected button
            buttons.forEach(btn => {
                btn.classList.remove('selected');
                btn.disabled = true;
            });
            buttonEl.classList.add('selected');
            
            // Get message text for context
            const messageEl = buttonEl.closest('.message');
            const textContent = messageEl.querySelector('.text-content')?.textContent || '';
            
            // Store feedback
            const feedback = {
                msgId: msgId,
                type: type, // 'positive' or 'negative'
                message: textContent.substring(0, 200),
                timestamp: new Date().toISOString(),
                level: currentLevel
            };
            feedbackData.push(feedback);
            
            // Add thank you message
            const thanks = document.createElement('span');
            thanks.className = 'feedback-thanks';
            thanks.textContent = type === 'positive' ? '‚ú® Grazie!' : 'üìù Noter√≤';
            feedbackContainer.appendChild(thanks);
            
            // Log to activity
            addLogEntry('system', `Feedback ${type === 'positive' ? 'üëç' : 'üëé'} ricevuto`, type === 'positive' ? 'üíö' : 'üìù');
            
            // Send to backend (if available)
            try {
                fetch(`${API_URL}/api/feedback`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(feedback)
                }).catch(() => {
                    // Silently fail - feedback stored locally
                    console.log('üìù Feedback stored locally');
                });
            } catch (e) {
                console.log('üìù Feedback stored locally');
            }
            
            // Show learning indicator for negative feedback
            if (type === 'negative') {
                setTimeout(() => showLearningIndicator('Feedback registrato per miglioramento'), 500);
            }
            
            console.log('üìä Feedback recorded:', feedback);
        }
        
        // ========== LEARNING INDICATOR ==========
        let learningHistory = [];
        
        function showLearningIndicator(insight) {
            // Create or get learning indicator
            let indicator = document.getElementById('learningIndicator');
            
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'learningIndicator';
                indicator.className = 'learning-indicator';
                document.body.appendChild(indicator);
            }
            
            // Store learning
            learningHistory.push({
                insight: insight,
                timestamp: new Date().toISOString()
            });
            
            // Update content
            indicator.innerHTML = `
                <span class="learning-icon">üí°</span>
                <span class="learning-text">Ho imparato: <strong>${insight}</strong></span>
            `;
            
            // Show with animation
            indicator.classList.add('visible');
            
            // Log to activity
            addLogEntry('system', `üí° Appreso: ${insight}`, 'üß†');
            
            // Hide after 4 seconds
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 4000);
        }
        
        // Trigger learning on certain events
        function triggerLearning(context) {
            const learnings = {
                'preference': 'Le tue preferenze di comunicazione',
                'topic': 'Un nuovo argomento di interesse',
                'correction': 'Una correzione utile',
                'pattern': 'Un pattern nelle tue richieste',
                'feedback': 'Il tuo feedback per migliorare'
            };
            
            const insight = learnings[context] || context;
            showLearningIndicator(insight);
        }
        
        // ========== ACTIVITY LOG FUNCTIONS ==========
        let activityLogEntries = [];
        
        function toggleActivityLog() {
            const panel = document.getElementById('activityLogPanel');
            panel.classList.toggle('visible');
            document.querySelector('.activity-log-btn').classList.remove('has-new');
        }
        
        function addLogEntry(type, message, icon = null) {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            
            const icons = {
                user: 'üë§',
                gideon: 'ü§ñ',
                system: '‚öôÔ∏è',
                error: '‚ùå',
                success: '‚úÖ',
                voice: 'üé§',
                tts: 'üîä'
            };
            
            const entry = {
                type: type,
                time: timeStr,
                icon: icon || icons[type] || 'üìå',
                message: message,
                timestamp: Date.now()
            };
            
            activityLogEntries.push(entry);
            
            // Keep max 100 entries
            if (activityLogEntries.length > 100) {
                activityLogEntries.shift();
            }
            
            renderLogEntry(entry);
            updateLogCount();
            
            // Flash button if panel is closed
            const panel = document.getElementById('activityLogPanel');
            if (!panel.classList.contains('visible')) {
                document.querySelector('.activity-log-btn').classList.add('has-new');
            }
        }
        
        function renderLogEntry(entry) {
            const container = document.getElementById('activityLogContent');
            const entryEl = document.createElement('div');
            entryEl.className = `log-entry ${entry.type}`;
            entryEl.dataset.type = entry.type;
            entryEl.innerHTML = `
                <span class="log-time">${entry.time}</span>
                <span class="log-icon">${entry.icon}</span>
                <span class="log-message">${entry.message}</span>
            `;
            container.appendChild(entryEl);
            container.scrollTop = container.scrollHeight;
        }
        
        function updateLogCount() {
            const count = activityLogEntries.length;
            document.getElementById('logCount').textContent = `${count} event${count !== 1 ? 'i' : 'o'}`;
        }
        
        function clearActivityLog() {
            activityLogEntries = [];
            document.getElementById('activityLogContent').innerHTML = '';
            addLogEntry('system', 'Log cancellato', 'üßπ');
        }
        
        function filterActivityLog(filter) {
            // Update active filter button
            document.querySelectorAll('.log-filter').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            
            // Filter entries
            document.querySelectorAll('.log-entry').forEach(entry => {
                if (filter === 'all') {
                    entry.style.display = 'flex';
                } else {
                    entry.style.display = entry.dataset.type === filter ? 'flex' : 'none';
                }
            });
        }
        
        // Initialize log filters
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.log-filter').forEach(btn => {
                btn.addEventListener('click', () => filterActivityLog(btn.dataset.filter));
            });
            
            // Add initial log entry
            setTimeout(() => {
                addLogEntry('system', 'Sessione GIDEON inizializzata', 'üöÄ');
            }, 500);
        });
        
        // ========== STEP 10.5: VOICE COMMANDS PANEL FUNCTIONS ==========
        function showVoiceCommandsPanel() {
            document.getElementById('voiceCommandsPanel').classList.add('show');
        }
        
        function hideVoiceCommandsPanel() {
            document.getElementById('voiceCommandsPanel').classList.remove('show');
        }
        
        function toggleVoiceCommandsPanel() {
            const panel = document.getElementById('voiceCommandsPanel');
            if (panel.classList.contains('show')) {
                hideVoiceCommandsPanel();
            } else {
                showVoiceCommandsPanel();
            }
        }

        function sendVoiceCommand(text) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('‚ö†Ô∏è CONNECTION LOST', 'gideon');
                playFeedbackSound('error');
                return;
            }
            
            // Check if user is asking Gideon to explain itself
            if (checkExplanationCommand(text)) {
                addMessage(text, 'user');
                explainGideon();
                playFeedbackSound('success');
                return;
            }

            addMessage(text, 'user');
            showTypingIndicator('PROCESSING VOICE...');
            updateHandsFreeIndicator('processing');
            
            ws.send(JSON.stringify({
                type: 'voice_command',
                payload: { text: text }
            }));
            
            commandCount++;
            document.getElementById('commands').textContent = commandCount;
        }

        // ========== GIDEON 3.0 API FUNCTIONS ==========
        async function processWithGideon(text) {
            try {
                const response = await fetch(`${GIDEON_API}/process`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, mode: currentMode })
                });
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('GIDEON API error:', error);
                return null;
            }
        }
        
        async function changeSystemMode(newMode) {
            try {
                const response = await fetch(`${SYSTEM_API}/mode`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: newMode })
                });
                const data = await response.json();
                if (data.success) {
                    currentMode = newMode;
                    updateModeIndicator(newMode);
                    addMessage(`üéõÔ∏è Modalit√† cambiata: ${newMode.toUpperCase()}`, 'gideon');
                }
                return data;
            } catch (error) {
                console.error('Mode change error:', error);
                return null;
            }
        }
        
        async function changeResponseLevel(level) {
            try {
                const response = await fetch(`${SYSTEM_API}/level`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ level: level })
                });
                const data = await response.json();
                if (data.success) {
                    responseLevel = level;
                    addMessage(`üìä Livello risposta: ${level.toUpperCase()}`, 'gideon');
                }
                return data;
            } catch (error) {
                console.error('Level change error:', error);
                return null;
            }
        }
        
        async function getSystemHealth() {
            try {
                const response = await fetch(`${API_URL}/health`);
                return await response.json();
            } catch (error) {
                console.error('Health check error:', error);
                return null;
            }
        }
        
        function updateModeIndicator(mode) {
            const modeNames = {
                'passive': 'üëÅÔ∏è PASSIVE',
                'copilot': 'ü§ù COPILOT', 
                'pilot': 'üöÄ PILOT',
                'executive': '‚ö° EXECUTIVE'
            };
            const indicator = document.getElementById('levelIndicator');
            if (indicator) {
                indicator.textContent = modeNames[mode] || mode.toUpperCase();
            }
        }

        // Connessione WebSocket
        function connectWebSocket() {
            ws = new WebSocket('ws://127.0.0.1:8001/ws');
            
            ws.onopen = () => {
                console.log('WebSocket connesso');
                updateStatus(true);
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnesso');
                updateStatus(false);
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus(false);
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
        }

        function updateStatus(online) {
            const statusEl = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            if (online) {
                statusEl.className = 'status online';
                statusText.textContent = 'CONNECTED';
            } else {
                statusEl.className = 'status offline';
                statusText.textContent = 'OFFLINE';
            }
        }

        function handleMessage(data) {
            console.log('Ricevuto:', data);
            
            // Hide typing indicator
            hideTypingIndicator();
            
            // Step 10: Update hands-free indicator to responding
            if (handsFreeMode) {
                updateHandsFreeIndicator('responding');
            }
            
            // ========== GIDEON 3.0 Response Handler ==========
            if (data.type === 'gideon_result') {
                handleGideonResponse(data.payload);
                return;
            }
            
            if (data.type === 'message_result' || data.type === 'command_result' || data.type === 'pilot_result') {
                const payload = data.payload;
                const text = payload.text || payload.response || payload.message || 'Risposta ricevuta';
                const isPilot = data.type === 'pilot_result' || payload.pilot_mode;
                
                // Get TTS-optimized text if available, otherwise use regular text
                const ttsText = payload.tts_text || text;
                
                // Feedback sonoro di successo
                playFeedbackSound('success');
                
                // Check if it's a pilot mode response
                if (isPilot) {
                    addPilotMessage(text, payload);
                }
                // Check if it's an autonomous thinking response
                else if (payload.intent === 'autonomous_thinking' && payload.data) {
                    addThinkingMessage(text, payload.data);
                } 
                // Check if it's a context-aware response
                else if (payload.context_aware && payload.turn_count > 0) {
                    addContextAwareMessage(text, payload.turn_count);
                }
                else {
                    addMessage(text, 'gideon');
                }
                
                // Parla la risposta se TTS attivo (usa tts_text per voce naturale)
                speak(ttsText);
                
                // Step 10: Mantieni conversazione attiva dopo risposta
                if (handsFreeMode) {
                    startContinuousConversation();
                    setTimeout(() => {
                        if (handsFreeMode) {
                            updateHandsFreeIndicator('idle');
                        }
                    }, 1000);
                }
                
                // Aggiorna metriche se disponibili
                if (payload.data && payload.data.cpu !== undefined) {
                    updateMetrics({
                        cpu: payload.data.cpu.usage_percent || payload.data.cpu,
                        memory: payload.data.memory.usage_percent || payload.data.memory,
                        disk: payload.data.disk.usage_percent || payload.data.disk
                    });
                }
            }
        }
        
        // ========== GIDEON 3.0 Response Handler ==========
        function handleGideonResponse(payload) {
            const text = payload.response || 'Operazione completata';
            const intent = payload.intent || {};
            const decision = payload.decision || {};
            
            playFeedbackSound('success');
            
            // Show cognitive trace if in advanced mode
            if (responseLevel === 'advanced' && payload.cognitive_trace) {
                addGideonAdvancedMessage(text, payload);
            } else {
                // Normal mode - simple response
                if (decision.outcome === 'confirm') {
                    addConfirmationMessage(text, payload);
                } else if (decision.outcome === 'suggest') {
                    addSuggestionMessage(text, payload);
                } else {
                    addMessage(text, 'gideon');
                }
            }
            
            speak(text);
            
            if (handsFreeMode) {
                startContinuousConversation();
            }
        }
        
        function addGideonAdvancedMessage(text, payload) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message gideon advanced-message';
            
            const intent = payload.intent || {};
            const decision = payload.decision || {};
            const trace = payload.cognitive_trace || [];
            
            messageEl.innerHTML = `
                <div class="message-avatar">G</div>
                <div class="message-text">
                    ${text}
                    <div class="cognitive-panel">
                        <div class="cognitive-header">üß† COGNITIVE TRACE</div>
                        <div class="cognitive-item">
                            <span class="cog-label">Intent:</span>
                            <span class="cog-value">${intent.name || 'unknown'} (${Math.round((intent.confidence || 0) * 100)}%)</span>
                        </div>
                        <div class="cognitive-item">
                            <span class="cog-label">Decision:</span>
                            <span class="cog-value">${decision.outcome || 'none'}</span>
                        </div>
                        <div class="cognitive-item">
                            <span class="cog-label">Time:</span>
                            <span class="cog-value">${payload.processing_time_ms || 0}ms</span>
                        </div>
                    </div>
                    <div class="message-time">${getTimeString()}</div>
                </div>
            `;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function addConfirmationMessage(text, payload) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message gideon confirmation-message';
            
            const pendingId = payload.pending_id || '';
            
            messageEl.innerHTML = `
                <div class="message-avatar">G</div>
                <div class="message-text">
                    ‚ö†Ô∏è ${text}
                    <div class="confirmation-buttons">
                        <button onclick="confirmAction('${pendingId}')" class="confirm-btn">‚úÖ Conferma</button>
                        <button onclick="rejectAction('${pendingId}')" class="reject-btn">‚ùå Annulla</button>
                    </div>
                    <div class="message-time">${getTimeString()}</div>
                </div>
            `;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function addSuggestionMessage(text, payload) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message gideon suggestion-message';
            
            const suggestions = payload.suggestions || [];
            const suggestionsHtml = suggestions.map((s, i) => 
                `<button onclick="applySuggestion('${s.action?.action || ''}')" class="suggest-btn">${i+1}. ${s.action?.action || 'Opzione'}</button>`
            ).join('');
            
            messageEl.innerHTML = `
                <div class="message-avatar">G</div>
                <div class="message-text">
                    üí° ${text}
                    <div class="suggestion-list">
                        ${suggestionsHtml}
                    </div>
                    <div class="message-time">${getTimeString()}</div>
                </div>
            `;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        async function confirmAction(pendingId) {
            try {
                const response = await fetch(`${GIDEON_API}/confirm/${pendingId}`, { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    addMessage('‚úÖ Azione confermata ed eseguita', 'gideon');
                }
            } catch (error) {
                addMessage('‚ùå Errore nella conferma', 'gideon');
            }
        }
        
        async function rejectAction(pendingId) {
            try {
                const response = await fetch(`${GIDEON_API}/reject/${pendingId}`, { method: 'POST' });
                const data = await response.json();
                addMessage('üö´ Azione annullata', 'gideon');
            } catch (error) {
                addMessage('‚ùå Errore', 'gideon');
            }
        }
        
        function applySuggestion(action) {
            if (action) {
                addMessage(`Eseguo: ${action}`, 'user');
                processWithGideon(action);
            }
        }

        
        // Add pilot mode message with special styling and enhanced data display
        function addPilotMessage(text, payload) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message gideon pilot-message';
            
            const time = getTimeString();
            const intent = payload.intent || 'pilot_command';
            const data = payload.data || {};
            
            // Build extra info display for different intents
            let extraInfo = '';
            
            if (intent === 'pilot_routine' && data.result) {
                extraInfo = `
                    <div class="pilot-data-panel">
                        <div class="pilot-data-header">üìä ROUTINE ESEGUITA</div>
                        <div class="pilot-data-steps">
                            ${data.steps_executed ? data.steps_executed.map((s, i) => 
                                `<div class="pilot-step">‚úÖ ${s}</div>`
                            ).join('') : ''}
                        </div>
                    </div>
                `;
            }
            
            if (intent === 'pilot_calculate' && data) {
                const metrics = Object.entries(data)
                    .filter(([k, v]) => typeof v === 'number')
                    .slice(0, 4);
                if (metrics.length > 0) {
                    extraInfo = `
                        <div class="pilot-data-panel">
                            <div class="pilot-data-header">üßÆ CALCOLI</div>
                            <div class="pilot-metrics">
                                ${metrics.map(([k, v]) => `
                                    <div class="pilot-metric">
                                        <span class="metric-label">${k.replace(/_/g, ' ')}</span>
                                        <span class="metric-value">${typeof v === 'number' ? v.toFixed(1) : v}${k.includes('percent') ? '%' : ''}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            }
            
            if (intent === 'pilot_decision' && data.decisions) {
                const decisions = data.decisions.slice(0, 3);
                extraInfo = `
                    <div class="pilot-data-panel">
                        <div class="pilot-data-header">üí° DECISIONI</div>
                        <div class="pilot-decisions">
                            ${decisions.map(d => `
                                <div class="pilot-decision ${d.priority || 'info'}">
                                    <span class="decision-area">[${d.area}]</span>
                                    <span class="decision-text">${d.suggestion}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (intent === 'pilot_full_control') {
                extraInfo = `
                    <div class="pilot-data-panel full-control">
                        <div class="pilot-data-header">üéÆ CONTROLLO COMPLETO ATTIVO</div>
                        <div class="pilot-control-status">
                            <div class="control-item"><span class="control-icon">üîí</span> Conferma interna: ATTIVA</div>
                            <div class="control-item"><span class="control-icon">üß†</span> Decisioni autonome: ABILITATE</div>
                            <div class="control-item"><span class="control-icon">üìä</span> Monitoraggio: CONTINUO</div>
                        </div>
                    </div>
                `;
            }
            
            if (data.confirmation) {
                const conf = data.confirmation;
                extraInfo += `
                    <div class="pilot-confirmation-badge ${conf.approved ? 'approved' : 'denied'}">
                        ${conf.approved ? '‚úÖ CONFERMATO' : 'üö´ NEGATO'} 
                        <span class="conf-confidence">(${Math.round(conf.confidence * 100)}%)</span>
                    </div>
                `;
            }
            
            // ========== STEP 9: Show auto-executed actions ==========
            if (data.actions_executed && data.actions_executed.length > 0) {
                extraInfo += `
                    <div class="pilot-data-panel auto-actions">
                        <div class="pilot-data-header">‚ö° AZIONI ESEGUITE AUTOMATICAMENTE</div>
                        <div class="pilot-actions-list">
                            ${data.actions_executed.map(action => `
                                <div class="pilot-action-item">
                                    <span class="action-check">‚úÖ</span>
                                    <span class="action-desc">${action.description}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Show reasoning complete indicator
            if (data.reasoning_complete) {
                extraInfo += `
                    <div class="reasoning-complete-badge">
                        üß† Ragionamento completato in ${data.thinking_time?.toFixed(1) || '?'}s
                    </div>
                `;
            }
            
            messageEl.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar pilot-avatar">üöÄ</div>
                    <div class="message-text">
                        ${text}
                        ${extraInfo}
                        <div class="message-time">${time} <span class="level-badge pilot">PILOT</span></div>
                    </div>
                </div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
            
            // Mark user message as seen
            markLastUserMessageSeen();
            
            logMessage('gideon', text, { level: 'pilot', intent: intent, data: data });
        }
        
        function showTypingIndicator(text = 'sta scrivendo') {
            const indicator = document.getElementById('typingIndicator');
            const typingText = document.getElementById('typingText');
            
            // Converti vecchi testi in stile WhatsApp
            const textMap = {
                'REASONING...': 'sta pensando',
                'PROCESSING VOICE...': 'elabora voce',
                'EXECUTING...': 'esegue comando',
                'ROLLING BACK...': 'annulla operazione',
                'ANALYZING...': 'analizza',
                'üöÄ PILOT ELABORA...': 'modalit√† pilot attiva'
            };
            
            const displayText = textMap[text] || text.toLowerCase().replace('...', '');
            typingText.textContent = displayText;
            indicator.classList.add('show');
            
            const messagesEl = document.getElementById('messages');
            messagesEl.scrollTop = messagesEl.scrollHeight;
            
            // Avatar 3D: stato thinking
            setAvatarState('thinking');
            
            // ========== Animazione typing WhatsApp-style ==========
            let dotCount = 0;
            window.typingInterval = setInterval(() => {
                dotCount = (dotCount + 1) % 4;
                // I dots CSS gi√† animano, qui aggiorniamo solo il testo se necessario
            }, 500);
        }
        
        function hideTypingIndicator() {
            if (window.typingInterval) {
                clearInterval(window.typingInterval);
            }
            document.getElementById('typingIndicator').classList.remove('show');
            
            // Avatar 3D: torna a idle (se non sta parlando)
            if (avatarState !== 'speaking') {
                setAvatarState('idle');
            }
        }
        
        function getTimeString() {
            const now = new Date();
            return now.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
        }
        
        function addMessage(text, sender) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = `message ${sender}`;
            
            const time = getTimeString();
            
            // Log the message
            logMessage(sender, text, { level: currentLevel, timestamp: new Date().toISOString() });
            
            // Add to Activity Log
            const truncatedText = text.length > 60 ? text.substring(0, 60) + '...' : text;
            if (sender === 'user') {
                addLogEntry('user', `Messaggio: "${truncatedText}"`, 'üí¨');
            } else if (sender === 'gideon') {
                addLogEntry('gideon', `Risposta: "${truncatedText}"`, 'ü§ñ');
            }
            
            if (sender === 'user') {
                // WhatsApp-style user message (right side with bubble tail)
                messageEl.innerHTML = `
                    <div class="message-bubble">
                        <div class="message-text-content">${text}</div>
                        <div class="message-meta">
                            <span class="message-timestamp">${time}</span>
                            <span class="message-checks sent">‚úì</span>
                        </div>
                    </div>
                `;
                // Simulate "delivered" checkmark after short delay
                setTimeout(() => {
                    const check = messageEl.querySelector('.message-checks');
                    if (check) {
                        check.textContent = '‚úì‚úì';
                        check.classList.remove('sent');
                        check.classList.add('delivered');
                    }
                }, 300);
            } else {
                // WhatsApp-style Gideon message (left side with hologram avatar)
                const levelBadge = currentLevel !== 'normal' ? 
                    `<span class="level-badge ${currentLevel}">${currentLevel.toUpperCase()}</span>` : '';
                
                const levelColor = currentLevel === 'pilot' ? '#00ff88' : 
                                   currentLevel === 'advanced' ? 'var(--neon-purple)' : 'var(--neon-cyan)';
                
                // Generate unique message ID for feedback
                const msgId = 'msg_' + Date.now();
                
                messageEl.innerHTML = `
                    <div class="message-content">
                        <div class="message-avatar hologram-mini" style="box-shadow: 0 0 15px ${levelColor};">
                            <span class="avatar-letter">G</span>
                            <div class="mini-scanline"></div>
                        </div>
                        <div class="message-bubble">
                            <span class="text-content"></span>
                            <div class="message-meta">
                                <span class="message-timestamp">${time}</span>
                                ${levelBadge}
                            </div>
                            <div class="message-feedback" data-msgid="${msgId}">
                                <button class="feedback-btn thumbs-up" onclick="sendFeedback('${msgId}', 'positive', this)" title="Risposta utile">üëç</button>
                                <button class="feedback-btn thumbs-down" onclick="sendFeedback('${msgId}', 'negative', this)" title="Risposta non utile">üëé</button>
                            </div>
                        </div>
                    </div>
                `;
                
                messagesEl.appendChild(messageEl);
                messagesEl.scrollTop = messagesEl.scrollHeight;
                
                // Animate text appearance
                const textContent = messageEl.querySelector('.text-content');
                typeText(textContent, text, 15);
                
                // Mark user message as "seen"
                markLastUserMessageSeen();
                
                // Mini avatar speaking animation
                const miniAvatar = messageEl.querySelector('.message-avatar');
                if (miniAvatar) {
                    miniAvatar.classList.add('speaking');
                    setTimeout(() => miniAvatar.classList.remove('speaking'), 2000);
                }
                return;
            }
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        // ========== GIDEON SELF-EXPLANATION FUNCTION ==========
        function explainGideon() {
            const explanation = `
ü§ñ <strong>Sono G.I.D.E.O.N.</strong><br>
<em>Generative Intelligence for Dynamic Executive Operations Network</em><br><br>

üìã <strong>I MIEI LIVELLI OPERATIVI:</strong><br>
üü¢ <strong>NORMAL (20% autonomia)</strong> - Assistente amichevole per domande e ricerche<br>
‚ö° <strong>ADVANCED (50% autonomia)</strong> - Analista profondo per ragionamenti complessi<br>
üöÄ <strong>PILOT (100% autonomia)</strong> - Intelligenza autonoma che agisce senza conferma<br><br>

üéØ <strong>LE MIE CAPACIT√Ä:</strong><br>
‚Ä¢ üé§ <strong>Interazione hands-free</strong> - Parla con me senza toccare nulla<br>
‚Ä¢ üí¨ <strong>Chat testuale</strong> - Scrivi come su WhatsApp<br>
‚Ä¢ üîä <strong>Voce sincronizzata</strong> - Parlo con lip-sync sull'avatar<br>
‚Ä¢ üß† <strong>Ragionamento autonomo</strong> - Penso prima di rispondere<br>
‚Ä¢ ‚öôÔ∏è <strong>Esecuzione azioni</strong> - In Pilot Mode eseguo comandi<br><br>

üîÆ <strong>IL MIO AVATAR:</strong><br>
Sono visualizzato come ologramma stile "The Flash" - una proiezione luminosa con effetti scanline e glitch per rappresentare la mia natura digitale.<br><br>

üí° <strong>COME USARMI:</strong><br>
‚Ä¢ Di' "Gideon" per attivare la modalit√† vocale<br>
‚Ä¢ Clicca sul livello in alto per cambiare modalit√†<br>
‚Ä¢ In Pilot Mode, dammi obiettivi e agisco autonomamente<br>
‚Ä¢ Di' "Gideon spiega te stesso" per rivedere questa guida
            `;
            
            addMessage(explanation.trim(), 'gideon');
            speak('Sono Gideon, la tua intelligenza artificiale personale. Posso operare in tre livelli: Normal per assistenza semplice, Advanced per analisi complesse, e Pilot per autonomia totale.');
        }
        
        // Check for self-explanation commands
        function checkExplanationCommand(text) {
            const lowerText = text.toLowerCase();
            const explanationTriggers = [
                'spiega te stesso', 'spiegati', 'chi sei', 'cosa sei',
                'come funzioni', 'cosa puoi fare', 'le tue funzioni',
                'explain yourself', 'who are you', 'what can you do',
                'presentati', 'descriviti', 'i tuoi livelli'
            ];
            
            for (const trigger of explanationTriggers) {
                if (lowerText.includes(trigger)) {
                    return true;
                }
            }
            return false;
        }
        
        // Typing effect for more natural feel
        function typeText(element, text, speed = 15) {
            let index = 0;
            // For long texts, show immediately
            if (text.length > 200) {
                element.innerHTML = text;
                return;
            }
            
            function type() {
                if (index < text.length) {
                    element.innerHTML = text.substring(0, index + 1);
                    index++;
                    setTimeout(type, speed);
                }
            }
            type();
        }
        
        // Mark user's last message as "seen"
        function markLastUserMessageSeen() {
            const userMessages = document.querySelectorAll('.message.user');
            if (userMessages.length > 0) {
                const lastUserMsg = userMessages[userMessages.length - 1];
                const check = lastUserMsg.querySelector('.message-check');
                if (check && !check.classList.contains('seen')) {
                    check.classList.add('seen');
                    check.style.color = '#00f5ff';
                }
            }
        }
        
        function addThinkingMessage(text, data) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message gideon thinking-message';
            
            // ========== STEP 9: Enhanced reasoning display ==========
            let html = '';
            
            // Header with reasoning indicator
            html += `<div class="thinking-header">
                <span class="thinking-icon">üß†</span>
                <span class="thinking-title">RAGIONAMENTO AUTONOMO</span>
            </div>`;
            
            // Thinking metrics
            if (data.thought_process) {
                const tp = data.thought_process;
                html += `<div class="thinking-metrics">
                    <span>‚è±Ô∏è ${tp.thinking_time_seconds.toFixed(1)}s</span>
                    <span>üìä Profondit√†: ${tp.depth_used || data.thinking_depth || 3}</span>
                    <span>üîó ${data.reasoning_steps || 5} passaggi</span>
                </div>`;
            }
            
            // Main response (formatted)
            html += `<div class="thinking-response">${text.replace(/\n/g, '<br>')}</div>`;
            
            // Reasoning quality indicator
            if (data.conclusion && data.conclusion.confidence) {
                const confidence = data.conclusion.confidence;
                const confidenceClass = confidence > 0.8 ? 'high' : confidence > 0.6 ? 'medium' : 'low';
                html += `<div class="thinking-confidence ${confidenceClass}">
                    üéØ Confidenza: ${(confidence * 100).toFixed(0)}%
                </div>`;
            }
            
            html += `<div class="message-time">${getTimeString()}</div>`;
            
            messageEl.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar thinking-avatar">üß†</div>
                    <div class="message-text">${html}</div>
                </div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
            
            // Log for traceability
            logMessage('gideon', text, { 
                intent: 'autonomous_thinking', 
                depth: data.thinking_depth,
                confidence: data.conclusion?.confidence 
            });
        }
        
        function addContextAwareMessage(text, turnCount) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message gideon';
            
            let contextIndicator = '';
            if (turnCount > 0) {
                contextIndicator = `<span style="opacity: 0.7; font-size: 0.8em;">üîÑ Turn ${turnCount}</span><br>`;
            }
            
            messageEl.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">G</div>
                    <div class="message-text">
                        ${contextIndicator}${text}
                        <div class="message-time">${getTimeString()}</div>
                    </div>
                </div>
            `;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('‚ö†Ô∏è CONNECTION LOST - Reconnecting...', 'gideon');
                connectWebSocket();
                return;
            }
            
            // ========== Check for Gideon self-explanation ==========
            if (checkExplanationCommand(message)) {
                addMessage(message, 'user');
                explainGideon();
                playFeedbackSound('success');
                input.value = '';
                return;
            }
            
            // ========== STEP 9: Check for pilot activation/deactivation via text ==========
            const msgLower = message.toLowerCase();
            
            // Check for pilot activation phrases (text input)
            if (PILOT_VOICE_PHRASES.some(phrase => msgLower.includes(phrase))) {
                addMessage(message, 'user');
                // For text activation, show security message
                addMessage('üîí Per sicurezza, la Modalit√† Pilot pu√≤ essere attivata solo tramite comando vocale. D√¨: "Assistente modalit√† pilota"', 'gideon');
                input.value = '';
                return;
            }
            
            // Check for pilot deactivation phrases (text input allowed)
            if (PILOT_DEACTIVATE_PHRASES.some(phrase => msgLower.includes(phrase))) {
                addMessage(message, 'user');
                if (pilotModeActive) {
                    deactivatePilotMode('text');
                } else {
                    addMessage('La Modalit√† Pilot non √® attiva.', 'gideon');
                }
                input.value = '';
                return;
            }
            
            addMessage(message, 'user');
            
            // ========== If in pilot mode, send as pilot command ==========
            if (pilotModeActive) {
                showTypingIndicator('üöÄ PILOT ELABORA...');
                
                ws.send(JSON.stringify({
                    type: 'pilot_command',
                    payload: { text: message, source: 'text' }
                }));
            } else {
                showTypingIndicator('REASONING...');
                
                ws.send(JSON.stringify({
                    type: 'text_message',
                    payload: { text: message }
                }));
            }
            
            input.value = '';
            commandCount++;
            document.getElementById('commands').textContent = commandCount;
        }

        function togglePilotMode() {
            if (!pilotModeActive) {
                // Cannot activate via button - voice only for security
                addMessage('üîí <strong>Attivazione vocale richiesta</strong><br><br>Per sicurezza, la Modalit√† Pilot pu√≤ essere attivata solo tramite comando vocale.<br><br>D√¨: <span style="color: #00ff88;">"Assistente modalit√† pilota"</span>', 'gideon');
                speak('Per attivare la modalit√† pilota, usa il comando vocale: Assistente modalit√† pilota');
            } else {
                // Can deactivate via button or voice
                deactivatePilotMode('button');
            }
        }
        
        // ========== PILOT MODE ACTIVATION ==========
        // Activate Pilot Mode (can be called from voice or button)
        function activatePilotMode(method = 'voice') {
            if (pilotModeActive) return;
            
            // ONLY voice activation allowed for security
            if (method !== 'voice') {
                addMessage('‚ö†Ô∏è La Modalit√† Pilot pu√≤ essere attivata solo tramite comando vocale per sicurezza. D√¨: "Assistente modalit√† pilota"', 'gideon');
                return;
            }
            
            pilotModeActive = true;
            document.getElementById('pilotBtn').classList.add('active');
            document.getElementById('pilotBtn').textContent = 'üö® PILOT ACTIVE';
            
            // Update level indicator
            setLevel('pilot');
            
            // Apply pilot mode visual effects
            document.body.classList.add('pilot-mode-active');
            
            // Trigger avatar transformation animation
            triggerPilotAvatarEffect();
            
            // Play activation sound effect (visual feedback)
            playPilotActivationEffect();
            
            // Notifica al backend
            fetch(`${API_URL}/api/pilot/activate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ method: method })
            });
            
            // Send level update via WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_level',
                    payload: { level: 'pilot' }
                }));
            }
            
            logEvent('PILOT_ACTIVATED', { method: method, voice_only: true });
            
            // Special pilot activation message
            const pilotMessage = `
                üö® <strong>MODALIT√Ä PILOTA ATTIVATA</strong><br><br>
                <span style="color: #00ff88;">‚úì Controllo completo sistema</span><br>
                <span style="color: #00ff88;">‚úì Esecuzione comandi autonoma</span><br>
                <span style="color: #00ff88;">‚úì Hands-free attivo</span><br>
                <span style="color: #00ff88;">‚úì Ascolto continuo in standby</span><br>
                <span style="color: #00ff88;">‚úì Interazione vocale E testuale</span><br><br>
                <small>Comandi: "routine...", "calcola...", "proponi decisione", "disattiva pilota"</small><br>
                <small>Puoi anche scrivere i comandi nella chat!</small><br><br>
                <button onclick="deactivatePilotMode('button')" style="background: #ff4444; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">üõë DISATTIVA PILOTA</button>
            `;
            addMessage(pilotMessage, 'gideon');
            speak('Modalit√† Pilota attivata. Sono in standby, pronto ai tuoi comandi. Puoi parlarmi o scrivere.');
            
            // ========== STEP 9: Enable continuous listening + standby ==========
            continuousMode = true;
            
            // Initialize recognition if needed
            if (!recognition) {
                initVoiceRecognition();
            }
            
            // Start listening (standby mode)
            if (!isListening && recognition) {
                try {
                    recognition.start();
                    document.getElementById('voiceStatus').textContent = 'üé§ PILOT STANDBY - In ascolto continuo';
                } catch (e) {
                    console.log('Recognition already active or error:', e);
                }
            }
            
            // Update voice button
            document.getElementById('voiceBtn').classList.add('listening', 'hands-free');
            document.getElementById('voiceBtn').textContent = 'üî¥ STANDBY';
            
            // Show hands-free indicator
            document.getElementById('handsFreeIndicator').classList.add('active');
            document.getElementById('handsFreeText').textContent = 'üöÄ PILOT STANDBY';
        }
        
        // Pilot Avatar Visual Effect
        function triggerPilotAvatarEffect() {
            const avatar = document.querySelector('.avatar');
            if (avatar) {
                // Add flash effect
                avatar.style.transition = 'all 0.3s ease';
                avatar.style.transform = 'scale(1.3)';
                avatar.style.filter = 'brightness(2)';
                
                setTimeout(() => {
                    avatar.style.transform = '';
                    avatar.style.filter = '';
                }, 300);
            }
        }
        
        // Pilot Activation Visual Effect
        function playPilotActivationEffect() {
            // Create flash overlay
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle, rgba(0,255,136,0.3) 0%, transparent 70%);
                z-index: 9999;
                pointer-events: none;
                animation: pilotFlash 0.5s ease-out forwards;
            `;
            document.body.appendChild(flash);
            
            // Add keyframe animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pilotFlash {
                    0% { opacity: 1; transform: scale(0.5); }
                    100% { opacity: 0; transform: scale(2); }
                }
            `;
            document.head.appendChild(style);
            
            setTimeout(() => {
                flash.remove();
                style.remove();
            }, 500);
            
            // Vibrate if supported (mobile)
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100]);
            }
        }
        
        // Deactivate Pilot Mode
        function deactivatePilotMode(method = 'voice') {
            if (!pilotModeActive) return;
            
            pilotModeActive = false;
            document.getElementById('pilotBtn').classList.remove('active');
            document.getElementById('pilotBtn').textContent = 'üöÄ PILOT MODE';
            
            // Remove pilot mode visual effects
            document.body.classList.remove('pilot-mode-active');
            
            // Reset to normal level
            setLevel('normal');
            
            fetch(`${API_URL}/api/pilot/deactivate`, { method: 'POST' });
            
            // Send level update via WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'set_level',
                    payload: { level: 'normal' }
                }));
            }
            
            // ========== STEP 9: Reset continuous listening ==========
            // Stop continuous mode unless hands-free is still active
            if (!handsFreeMode) {
                continuousMode = false;
                if (isListening) {
                    try {
                        recognition.stop();
                    } catch (e) {}
                }
            }
            
            // Reset voice button
            document.getElementById('voiceBtn').classList.remove('listening', 'hands-free');
            document.getElementById('voiceBtn').textContent = 'üé§ VOICE';
            
            // Hide hands-free indicator if not in hands-free mode
            if (!handsFreeMode) {
                document.getElementById('handsFreeIndicator').classList.remove('active');
            }
            
            document.getElementById('voiceStatus').textContent = 'MIC OFFLINE';
            
            logEvent('PILOT_DEACTIVATED', { method: method });
            
            const deactivateMessage = method === 'text' 
                ? '‚úÖ Modalit√† Pilota disattivata via testo. Ritorno alle operazioni normali.'
                : '‚úÖ Modalit√† Pilota disattivata. Ritorno alle operazioni normali.';
            
            addMessage(deactivateMessage, 'gideon');
            speak('Modalit√† Pilota disattivata.');
        }
        
        // Check if text contains pilot activation phrase
        function checkPilotActivation(text) {
            const lowerText = text.toLowerCase().trim();
            
            // Check for activation
            for (const phrase of PILOT_VOICE_PHRASES) {
                if (lowerText.includes(phrase)) {
                    return 'activate';
                }
            }
            
            // Check for deactivation
            for (const phrase of PILOT_DEACTIVATE_PHRASES) {
                if (lowerText.includes(phrase)) {
                    return 'deactivate';
                }
            }
            
            return null;
        }
        
        // Execute pilot command with smart command detection
        async function executePilotCommand(command) {
            if (!pilotModeActive) return;
            
            logEvent('PILOT_COMMAND', { command: command });
            
            // Detect command type for appropriate indicator
            const cmdLower = command.toLowerCase();
            let indicatorText = 'EXECUTING PILOT COMMAND...';
            
            if (cmdLower.includes('routine') || cmdLower.includes('automazione')) {
                indicatorText = '‚öôÔ∏è EXECUTING ROUTINE...';
            } else if (cmdLower.includes('calcola') || cmdLower.includes('percentuale')) {
                indicatorText = 'üßÆ CALCULATING...';
            } else if (cmdLower.includes('proponi') || cmdLower.includes('decisione')) {
                indicatorText = 'üí° ANALYZING DECISIONS...';
            } else if (cmdLower.includes('ottimizza')) {
                indicatorText = 'üîß OPTIMIZING SYSTEM...';
            } else if (cmdLower.includes('controllo') || cmdLower.includes('comanda')) {
                indicatorText = 'üéÆ ACTIVATING FULL CONTROL...';
            } else if (cmdLower.includes('analizza') || cmdLower.includes('scansiona')) {
                indicatorText = 'üîç DEEP ANALYSIS...';
            }
            
            // Show executing status
            showTypingIndicator(indicatorText);
            
            // Send to backend with pilot flag
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'pilot_command',
                    payload: { 
                        text: command,
                        pilot_mode: true,
                        execute: true
                    }
                }));
            }
        }
        
        // Toggle Advanced mode
        function toggleAdvancedMode() {
            if (currentLevel === 'advanced') {
                setLevel('normal');
                addMessage('üìä Switched to NORMAL mode.', 'gideon');
            } else if (currentLevel === 'normal') {
                setLevel('advanced');
                addMessage('‚ö° Switched to ADVANCED mode. Enhanced analysis enabled.', 'gideon');
            }
            // Can't toggle if in pilot mode
        }

        async function updateMemoryStats() {
            try {
                const response = await fetch(`${API_URL}/api/memory/conversation?limit=20`);
                if (response.ok) {
                    const data = await response.json();
                    const memoryCount = data.history ? data.history.length : 0;
                    document.getElementById('memoryCount').textContent = memoryCount;
                }
            } catch (error) {
                console.error('Error updating memory stats:', error);
            }
        }

        function sendQuickMessage(message) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('‚ö†Ô∏è CONNECTION LOST - Reconnecting...', 'gideon');
                connectWebSocket();
                return;
            }
            
            addMessage(message, 'user');
            showTypingIndicator('ANALYZING...');
            
            ws.send(JSON.stringify({
                type: 'text_message',
                payload: { text: message }
            }));
            
            commandCount++;
            document.getElementById('commands').textContent = commandCount;
        }

        function updateMetrics(metrics) {
            if (metrics.cpu !== undefined) {
                document.getElementById('cpu').textContent = metrics.cpu.toFixed(1) + '%';
                document.getElementById('cpuBar').style.width = metrics.cpu + '%';
            }
            if (metrics.memory !== undefined) {
                document.getElementById('memory').textContent = metrics.memory.toFixed(1) + '%';
                document.getElementById('memoryBar').style.width = metrics.memory + '%';
            }
            if (metrics.disk !== undefined) {
                document.getElementById('disk').textContent = metrics.disk.toFixed(1) + '%';
                document.getElementById('diskBar').style.width = metrics.disk + '%';
            }
            if (metrics.efficiency !== undefined) {
                document.getElementById('efficiency').textContent = (metrics.efficiency * 100).toFixed(1) + '%';
            }
        }

        // Carica stato sistema ogni 5 secondi
        async function fetchSystemStatus() {
            try {
                const response = await fetch(`${API_URL}/health`);
                const data = await response.json();
                
                if (data.system) {
                    updateMetrics(data.system);
                }
                
                // Update memory stats
                updateMemoryStats();
            } catch (error) {
                console.error('Errore health check:', error);
            }
        }
        
        // Load previous log from localStorage
        function loadPreviousLog() {
            try {
                const savedLog = localStorage.getItem('gideon_log');
                if (savedLog) {
                    conversationLog = JSON.parse(savedLog);
                    console.log(`üìã Loaded ${conversationLog.length} previous log entries`);
                }
            } catch (e) {
                console.warn('Could not load previous log:', e);
            }
        }

        // Inizializzazione quando il DOM √® pronto
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Initializing Gideon 2.0...');
            
            // Load previous conversation log
            loadPreviousLog();
            
            // Log system start
            logEvent('SYSTEM_START', { 
                version: '2.0', 
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString()
            });
            
            // Gestione Enter per inviare
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // Inizializzazione servizi
            connectWebSocket();
            initTTS();
            initVoiceRecognition();
            setInterval(fetchSystemStatus, 5000);
            
            // Set initial level
            setLevel('normal');
            
            // Messaggio di benvenuto migliorato con guida voce
            setTimeout(() => {
                speak('Gideon online. Sono pronto ad ascoltarti.');
                document.getElementById('voiceStatus').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span>üé§ Premi <strong>VOICE</strong> per parlare</span>
                        <span style="font-size: 0.8em; opacity: 0.7;">oppure attiva <strong>HANDS-FREE</strong> per parlare liberamente</span>
                    </div>
                `;
                
                // Mostra dialog per attivare hands-free automaticamente
                showVoiceModeDialog();
            }, 1000);
            
            console.log('‚úÖ Gideon 2.0 initialized. All responses logged for traceability.');
            console.log('üìã Use exportLog() in console to view conversation history.');
        });
        
        // Dialog per scegliere modalit√† voce
        function showVoiceModeDialog() {
            // Crea overlay dialog
            const overlay = document.createElement('div');
            overlay.id = 'voiceModeDialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease;
            `;
            
            overlay.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, rgba(15, 15, 35, 0.95), rgba(25, 25, 55, 0.95));
                    border: 2px solid var(--neon-cyan);
                    border-radius: 20px;
                    padding: 40px;
                    max-width: 500px;
                    text-align: center;
                    box-shadow: 0 0 50px rgba(0, 245, 255, 0.3);
                    animation: scaleIn 0.3s ease;
                ">
                    <h2 style="color: var(--neon-cyan); font-family: 'Orbitron', sans-serif; margin-bottom: 20px; font-size: 1.8em;">
                        üé§ Come vuoi interagire?
                    </h2>
                    <p style="color: #aaa; margin-bottom: 30px; line-height: 1.6;">
                        Scegli come preferisci comunicare con Gideon:
                    </p>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <button onclick="selectVoiceMode('handsfree')" style="
                            background: linear-gradient(135deg, #00f5ff, #0080ff);
                            color: #000;
                            border: none;
                            padding: 20px 30px;
                            border-radius: 15px;
                            font-size: 1.1em;
                            font-weight: bold;
                            cursor: pointer;
                            transition: all 0.3s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 15px;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            <span style="font-size: 2em;">üôå</span>
                            <div style="text-align: left;">
                                <div>HANDS-FREE (Consigliato)</div>
                                <div style="font-size: 0.8em; font-weight: normal; opacity: 0.8;">
                                    D√¨ "Gideon" per parlare liberamente
                                </div>
                            </div>
                        </button>
                        
                        <button onclick="selectVoiceMode('pushToTalk')" style="
                            background: rgba(255, 255, 255, 0.1);
                            color: #fff;
                            border: 1px solid rgba(255, 255, 255, 0.3);
                            padding: 20px 30px;
                            border-radius: 15px;
                            font-size: 1.1em;
                            font-weight: bold;
                            cursor: pointer;
                            transition: all 0.3s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 15px;
                        " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                            <span style="font-size: 2em;">üé§</span>
                            <div style="text-align: left;">
                                <div>PUSH-TO-TALK</div>
                                <div style="font-size: 0.8em; font-weight: normal; opacity: 0.8;">
                                    Premi il pulsante per parlare
                                </div>
                            </div>
                        </button>
                        
                        <button onclick="selectVoiceMode('text')" style="
                            background: transparent;
                            color: #888;
                            border: 1px solid rgba(255, 255, 255, 0.1);
                            padding: 15px 30px;
                            border-radius: 15px;
                            font-size: 0.9em;
                            cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#888'">
                            ‚å®Ô∏è Preferisco scrivere
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        function selectVoiceMode(mode) {
            const dialog = document.getElementById('voiceModeDialog');
            if (dialog) {
                dialog.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => dialog.remove(), 300);
            }
            
            switch(mode) {
                case 'handsfree':
                    activateHandsFree();
                    addMessage('üôå Modalit√† Hands-Free attivata! D√¨ "Gideon" quando vuoi parlarmi.', 'gideon');
                    speak('Hands-free attivato. Dimmi Gideon quando hai bisogno di me.');
                    break;
                case 'pushToTalk':
                    addMessage('üé§ Modalit√† Push-to-Talk attiva. Premi il pulsante VOICE quando vuoi parlare.', 'gideon');
                    speak('Push to talk attivo. Premi il pulsante voice quando vuoi parlare.');
                    break;
                case 'text':
                    addMessage('‚å®Ô∏è Perfetto! Scrivi pure nella casella di testo qui sotto.', 'gideon');
                    break;
            }
        }
    </script>
</body>
</html>

